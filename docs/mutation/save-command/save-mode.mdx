---
sidebar_position: 3
title: Save Mode of Aggregate-Root
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import Key from '../../_shared/key.mdx';
import { ViewMore } from '@site/src/components/ViewMore';

## Save Modes

The save command supports 5 save modes that control how the aggregate root itself is saved:

-   UPSERT: This is the default mode. It first queries to check if the aggregate root object being saved exists:

    -   If it doesn't exist: Executes an INSERT statement

    -   If it exists: Executes an UPDATE statement

-   INSERT_ONLY: Unconditionally executes an INSERT statement

-   INSERT_IF_ABSENT: 

    -   If the data already exists, ignores the operation
    
    -   Otherwise, inserts the data

-   UPDATE_ONLY: Unconditionally executes an UPDATE statement

-   NON_IDEMPOTENT_UPSERT: 

    -   If the object's @Id property or @Key properties are specified, performs behavior equivalent to UPSERT

    -   Otherwise, performs an INSERT operation

    :::note
    This behavior is equivalent to JPA's `merge` or Hibernate's `saveOrUpdate`, but it is not recommended in Jimmer.
    :::

:::caution
Save modes only affect the aggregate root object, not other associated objects.

For associated objects, please refer to [Associated Object Save Mode](./associated-save-mode).
:::

## INSERT_ONLY

`INSERT_ONLY` means unconditionally inserting data

<Tabs groupId="language">
<TabItem value="java" label="Java">

```java
List<Book> books = Arrays.asList(
    Immutables.createBook(draft -> {
        draft.setName("SQL in Action");
        draft.setEdition(3);
        draft.setPrice(new BigDecimal("49.9"));
        draft.setStoreId(2L);
    }),
    Immutables.createBook(draft -> {
        draft.setName("LINQ in Action");
        draft.setEdition(2);
        draft.setPrice(new BigDecimal("39.9"));
        draft.setStoreId(2L);
    })
);

List<Long> allocatedIds = sqlClient    
    .saveEntities(
        books, 
        // highlight-next-line
        SaveMode.INSERT_ONLY
    )
    .getItems()
    .stream()
    .map(item -> item.getModifiedEntity().id())
    .collect(Collectors.toList());

System.out.println("Allocated ids: " + allocatedIds);
```

</TabItem>
<TabItem value="kotlin" label="Kotlin">

```kotlin
val books = listOf(
    Book {
        name = "SQL in Action"
        edition = 3
        price = BigDecimal("49.9")
        storeId = 2L
    },
    Book {
        name = "SQL in Action"
        edition = 2
        price = BigDecimal("39.9")
        storeId = 2L
    }
)

val allocatedIds = sqlClient
    .saveEntities(
        books,
        // highlight-next-line
        SaveMode.INSERT_ONLY
    )
    .items
    .map {
        it.modifiedEntity.id
    }

println("Allocated ids: $allocatedIds")
```

</TabItem>
</Tabs>

INSERT_ONLY works very simply - it inserts unconditionally without any checks.

The generated batch operation SQL is as follows:

```sql
insert into BOOK(NAME, EDITION, PRICE, STORE_ID) values(?, ?, ?, ?)
/* batch-0: SQL in Action, 3, 49.9, 2 */
/* batch-1: [LINQ in Action, 2, 39.9, 2 */
```

In this example, since the id property's corresponding column uses database auto-numbering, after the batch insertion is complete, the ids allocated by the database for all data will be returned. The print result will be:

```
Allocated ids: [100, 101]
```

## UPDATE_ONLY

`UPDATE_ONLY` means unconditionally updating data, and it has two scenarios:

-   For Id-Specified objects, modify data according to id

-   For Key-Specified objects, modify data according to key

### Updating Data by ID

<Tabs groupId="language">
<TabItem value="java" label="Java">

```java
List<Book> books = Arrays.asList(
    Immutables.createBook(draft -> {
        draft.setId(3L); // Matched
        draft.setName("SQL in Action");
        draft.setEdition(3);
        draft.setPrice(new BigDecimal("49.9"));
        draft.setStoreId(2L);
    }),
    Immutables.createBook(draft -> {
        draft.setId(100L); // Not matched
        draft.setName("LINQ in Action");
        draft.setEdition(2);
        draft.setPrice(new BigDecimal("39.9"));
        draft.setStoreId(2L);
    })
);
BatchSaveResult<Book> result = sqlClient
    .saveEntities(
        books,
        // highlight-next-line
        SaveMode.UPDATE_ONLY
    );
System.out.println("Affected row count: " + result.getTotalAffectedRowCount());
```

</TabItem>
<TabItem value="kotlin" label="Kotlin">

```kotlin
val books = listOf(
    Book {
        id = 3L
        name = "SQL in Action"
        edition = 3
        price = BigDecimal("49.9")
        storeId = 2L
    },
    Book {
        id = 100L
        name = "SQL in Action"
        edition = 2
        price = BigDecimal("39.9")
        storeId = 2L
    }
)
val result = sqlClient
    .saveEntities(
        books,
        // highlight-next-line
        SaveMode.UPDATE_ONLY
    )

println("Affected row count: ${result.totalAffectedRowCount}")
```

</TabItem>
</Tabs>

Since the object's id property is specified, the object is updated based on its id. The generated batch operation SQL is as follows:

```sql
update BOOK
set
    NAME = ?,
    EDITION = ?,
    PRICE = ?,
    STORE_ID = ?
where
    ID = ?
/* batch-0: [SQL in Action, 3, 49.9, 2, 3] *
/* batch-1: [LINQ in Action, 2, 39.9, 2, 100] */
```

This batch operation attempts to modify two records. Assuming the database only has one matching record, the print result will be `1`.

### Updating Data by Key

Assume the Book entity is defined as follows:

<Tabs groupId="language">
<TabItem value="java" label="Java">

```java title="Book.java"
@Entity
public interface Book {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    long id();

    // highlight-next-line
    @Key
    String name();

    // highlight-next-line
    @Key
    int edition();

    ...other properties that are neither id nor key omitted...
}
```

</TabItem>
<TabItem value="kotlin" label="Kotlin">

```kotlin title="Book.kt"
@Entity
public interface Book {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    val id: Long

    // highlight-next-line
    @Key
    val name: String

    // highlight-next-line
    @Key
    val edition: Int

    ...other properties that are neither id nor key omitted...
}
```

</TabItem>
</Tabs>

Here `Book.name` and `Book.edition` are annotated with [@Key](../../mapping/advanced/key).

<Tabs groupId="language">
<TabItem value="java" label="Java">

```java
List<Book> books = Arrays.asList(
    Immutables.createBook(draft -> {
        // Id is not specified
        draft.setName("Learning GraphQL");
        draft.setEdition(3);
        draft.setPrice(new BigDecimal("49.9"));
        draft.setStoreId(2L);
    }),
    Immutables.createBook(draft -> {
        // Id is not specified
        draft.setName("LINQ in Action");
        draft.setEdition(2);
        draft.setPrice(new BigDecimal("39.9"));
        draft.setStoreId(2L);
    })
);
BatchSaveResult<Book> result = sqlClient
    .saveEntities(
        books,
        // highlight-next-line
        SaveMode.UPDATE_ONLY
    );
for (MutationResultItem<Book> item : result.getItems()) {
    if (ImmutableObjects.isLoaded(item.getModifiedEntity(), BookProps.ID)) {
        System.out.println("Data is updated, updated id is " + item.getModifiedEntity().id());
    } else {
        System.out.println("Data is not updated");
    }
}
```

</TabItem>
<TabItem value="kotlin" label="Kotlin">

```kotlin
val books = listOf(
    Book {
        // Id is not specified
        name = "Learning GraphQL"
        edition = 3
        price = BigDecimal("49.9")
        storeId = 2L
    },
    Book {
        // Id is not specified
        name = "SQL in Action"
        edition = 2
        price = BigDecimal("39.9")
        storeId = 2L
    }
)
val result = sqlClient
    .saveEntities(
        books,
        // highlight-next-line
        SaveMode.UPDATE_ONLY
    )
for (item in result.item) {
    if (isLoaded(item.modifiedEntity, Book::id)) {
        println("Data is updated, updated id is ${item.isModified}")
    } else {
        println("Data is not updated")
    }
}
```

</TabItem>
</Tabs>

Since the object's id property is not specified, the object is updated based on its key. The generated batch operation SQL is as follows:

```sql
update BOOK
set
    PRICE = ?,
    STORE_ID = ?
where
    NAME = ?
    and
    EDITION = ?
/* batch-0: [49.9, 2, Learning GraphQL, 3] */
/* batch-1: [39.9, 2, LINQ in Action, 2] */
```

The print result will be:

```
Data is updated, updated id is 3
Data is not updated
```

## UPSERT

`UPSERT` means first checking if the data exists - if it exists then update it, otherwise insert it

- For Id-Specified objects, existence is determined by id, then deciding between INSERT or UPDATE

- For Key-Specified objects, existence is determined by key, then deciding between INSERT or UPDATE

### Determining Data Existence by Id

<Tabs groupId="language">
<TabItem value="java" label="Java">

```java
List<Book> books = Arrays.asList(
    Immutables.createBook(draft -> {
        draft.setId(3L);
        draft.setName("Learning GraphQL");
        draft.setEdition(3);
        draft.setPrice(new BigDecimal("49.9"));
        draft.setStoreId(2L);
    }),
    Immutables.createBook(draft -> {
        draft.setId(90L);
        draft.setName("LINQ in Action");
        draft.setEdition(2);
        draft.setPrice(new BigDecimal("39.9"));
        draft.setStoreId(2L);
    })
);

sqlClient
    .saveEntities(
        books,
        // highlight-next-line
        SaveMode.UPSERT
    );
```

</TabItem>
<TabItem value="kotlin" label="Kotlin">

```kotlin
val books = listOf(
    Book {
        id = 3L
        name = "Learning GraphQL"
        edition = 3
        price = BigDecimal("49.9")
        storeId = 2L
    },
    Book {
        id = 90L
        name = "SQL in Action"
        edition = 2
        price = BigDecimal("39.9")
        storeId = 2L
    }
)
sqlClient.save(
    books,
    // highlight-next-line
    SaveMode.UPSERT
)
```

</TabItem>
</Tabs>

Jimmer prioritizes using the database's native UPSERT capabilities, so it generates different SQL for different databases

<table>
<thead>
<tr>
<th>Database</th>
<th>Generated SQL</th>
</tr>
</thead>
<tbody>
<tr>
<td>H2</td>
<td>

```sql
merge into BOOK(
    ID, NAME, EDITION, PRICE, STORE_ID
) key(ID) values(
    ?, ?, ?, ?, ?
)
/* batch-0: [3, Learning GraphQL, 3, 49.9, 2] */
/* batch-1: [90, LINQ in Action, 2, 39.9, 2] */
```

</td>
</tr>
<tr>
<td>MySQL</td>
<td>

```sql
insert into BOOK(
    ID, NAME, EDITION, PRICE, STORE_ID
) values(?, ?, ?, ?, ?)
on duplicate key update 
    NAME = values(NAME), 
    EDITION = values(EDITION), 
    PRICE = values(PRICE), 
    STORE_ID = values(STORE_ID)
/* batch-0: [3, Learning GraphQL, 3, 49.9, 2] */
/* batch-1: [90, LINQ in Action, 2, 39.9, 2] */
```

</td>
</tr>
<tr>
<td>Postgres</td>
<td>

```sql
insert into BOOK(
    ID, NAME, EDITION, PRICE, STORE_ID
) values(?, ?, ?, ?, ?)
on conflict(ID) do update set
    NAME = excluded.NAME, 
    EDITION = excluded.EDITION, 
    PRICE = excluded.PRICE, 
    STORE_ID = excluded.STORE_ID)
/* batch-0: [3, Learning GraphQL, 3, 49.9, 2] */
/* batch-1: [90, LINQ in Action, 2, 39.9, 2] */
```

</td>
</tr>
</tbody>
</table>

### Determining Data Existence by Key

If the object's id is not specified, for example:

<Tabs groupId="language">
<TabItem value="java" label="Java">

```java
List<Book> books = Arrays.asList(
    Immutables.createBook(draft -> {
        draft.setName("Learning GraphQL");
        draft.setEdition(3);
        draft.setPrice(new BigDecimal("49.9"));
        draft.setStoreId(2L);
    }),
    Immutables.createBook(draft -> {
        draft.setName("GraphQL in Action");
        draft.setEdition(3);
        draft.setPrice(new BigDecimal("49.9"));
        draft.setStoreId(2L);
    }),
    Immutables.createBook(draft -> {
        draft.setName("LINQ in Action");
        draft.setEdition(2);
        draft.setPrice(new BigDecimal("39.9"));
        draft.setStoreId(2L);
    }),
    Immutables.createBook(draft -> {
        draft.setName("Kotlin in Action");
        draft.setEdition(2);
        draft.setPrice(new BigDecimal("39.9"));
        draft.setStoreId(2L);
    })
);
List<Long> ids = sqlClient
    .saveEntities(
        books,
        // highlight-next-line
        SaveMode.UPSERT
    )
    .getItems()
    .stream().map(it -> it.getModifiedEntity().id())
    .collect(Collectors.toList());
System.out.println(ids);
```

</TabItem>
<TabItem value="kotlin" label="Kotlin">

```kotlin
val books = listOf(
    Book {
        name = "Learning GraphQL"
        edition = 3
        price = BigDecimal("49.9")
        storeId = 2L
    },
    Book {
        name = "GraphQL in Action"
        edition = 3
        price = BigDecimal("49.9")
        storeId = 2L
    },
    Book {
        name = "SQL in Action"
        edition = 2
        price = BigDecimal("39.9")
        storeId = 2L
    },
    Book {
        name = "Kotlin in Action"
        edition = 2
        price = BigDecimal("39.9")
        storeId = 2L
    }
)
val ids = sqlClient.save(
    books,
    // highlight-next-line
    SaveMode.UPSERT
).items.map{ it.id }
println(ids)
```

</TabItem>
</Tabs>

By default, Jimmer tries to use the database's native UPSERT capabilities whenever possible.

However, in this case, it cannot achieve this *(we'll discuss how to solve this issue shortly)*.

In this situation, Jimmer will first execute a query, then based on the query results, determine which data should be INSERTed and which should be UPDATEd. This results in three SQL statements:

1.  Query, with reason provided
    ```sql
    /* highlight-next-line */
    Purpose: COMMAND(KEY_UNIQUE_CONSTRAINT_REQUIRED)
    SQL: select
        tb_1_.ID,
        tb_1_.NAME,
        tb_1_.EDITION
    from BOOK tb_1_
    where
        (tb_1_.NAME, tb_1_.EDITION) in (
            (? /* Learning GraphQL */, ? /* 3 */), 
            (? /* GraphQL in Action */, ? /* 3 */), 
            (? /* LINQ in Action */, ? /* 2 */), 
            (? /* Kotlin in Action */, ? /* 2 */)
        )
    ```

    :::info
    Jimmer prints `KEY_UNIQUE_CONSTRAINT_REQUIRED` in the logs, which is called QueryReason.

    Jimmer prioritizes using the database's native UPSERT capabilities, and if it cannot do so resulting in a query, it provides the QueryReason to help users investigate and find solutions.
    :::

2.  INSERT operation for non-existing data

    ```sql
    insert into BOOK(
        NAME, EDITION, PRICE, STORE_ID
    ) values(
        ?, ?, ?, ?
    )
    /* batch-0: [LINQ in Action, 2, 39.9, 2] */
    /* batch-1: [Kotlin in Action, 2, 39.9, 2] */
    ```

3.  UPDATE operation for existing data

    ```sql
    update BOOK
    set
        PRICE = ?,
        STORE_ID = ?
    where
        ID = ?
    /* batch-0: [49.9, 2, 3] */
    /* batch-1: [49.9, 2, 12] */
    ```

The printed result is:

```
[3, 12, 100, 101]
```   
Where:
-   3 and 12 represent the ids of updated data
-   100 and 101 represent new ids assigned by the database for inserted data

### Improved Key-based Determination

In the previous example, Jimmer executed a query and provided the QueryReason `KEY_UNIQUE_CONSTRAINT_REQUIRED`.

Jimmer provides detailed documentation comments for all QueryReasons, see [QueryReason](https://github.com/babyfish-ct/jimmer/blob/main/project/jimmer-sql/src/main/java/org/babyfish/jimmer/sql/ast/mutation/QueryReason.java) for details.

For `KEY_UNIQUE_CONSTRAINT_REQUIRED` specifically, it indicates the need for:

1.  Creating a unique constraint for `Book.name` and `Book.edition` properties:

    ```sql
    alter table book
        add constraint uq_book__name_edition
            /* highlight-next-line */
            unique(name, edition);
    ```

    This is because the database's UPSERT functionality depends on unique constraints *(or unique indexes)*

2.  Informing Jimmer through the `@KeyUniqueConstraint` annotation that the properties modified by `@Key` have corresponding unique constraints *(or unique indexes)* in the database

    <Tabs groupId="language">
    <TabItem value="java" label="Java">

    ```java title="Book.java"
    @Entity
    // highlight-next-line
    @KeyUniqueConstraint
    public interface Book {

        @Id
        @GeneratedValue(strategy = GenerationType.IDENTITY)
        long id();

        @Key
        String name();

        @Key
        int edition();

        ...omitting other properties that are neither id nor key...
    }
    ```

    </TabItem>
    <TabItem value="kotlin" label="Kotlin">

    ```kotlin title="Book.kt"
    @Entity
    // highlight-next-line
    @KeyUniqueConstraint
    public interface Book {

        @Id
        @GeneratedValue(strategy = GenerationType.IDENTITY)
        val id: Long

        @Key
        val name: String

        @Key
        val edition: Int

        ...omitting other properties that are neither id nor key...
    }
    ```

    </TabItem>
    </Tabs>

    :::caution
    For MySQL, you need:
    ```java
    @KeyUniqueConstraint(noMoreUniqueConstraints = true)
    ```
    :::

Once these two improvements are made, when running the previous example again, Jimmer will no longer execute a select statement but instead directly utilize the database's native UPSERT capabilities

<table>
<thead>
<tr>
<th>Database</th>
<th>Generated SQL</th>
</tr>
</thead>
<tbody>
<tr>
<td>H2</td>
<td>

```sql
merge into BOOK(
    NAME, EDITION, PRICE, STORE_ID
) key(
    /* highlight-next-line */
    NAME, EDITION
) values(
    ?, ?, ?, ?
)
/* batch-0: [Learning GraphQL, 3, 49.9, 2] */
/* batch-1: [GraphQL in Action, 3, 49.9, 2] */
/* batch-2: [LINQ in Action, 2, 39.9, 2] */
/* batch-3: [Kotlin in Action, 2, 39.9, 2] */
```

</td>
</tr>
<tr>
<td>MySQL</td>
<td>

```sql
insert into BOOK(
    NAME, EDITION, PRICE, STORE_ID
) values(?, ?, ?, ?)
on duplicate key update 
    /* fake update to return all ids */ ID = last_insert_id(ID), 
    NAME = values(NAME), 
    EDITION = values(EDITION), 
    PRICE = values(PRICE), 
    STORE_ID = values(STORE_ID)
/* batch-0: [Learning GraphQL, 3, 49.9, 2] */
/* batch-1: [GraphQL in Action, 3, 49.9, 2] */
/* batch-2: [LINQ in Action, 2, 39.9, 2] */
/* batch-3: [Kotlin in Action, 2, 39.9, 2] */
```

</td>
</tr>
<tr>
<td>Postgres</td>
<td>

```sql
insert into BOOK(
    NAME, EDITION, PRICE, STORE_ID
) values(?, ?, ?, ?, ?)
on conflict(
    /* highlight-next-line */
    NAME, EDITION
) do update set
    NAME = excluded.NAME, 
    EDITION = excluded.EDITION, 
    PRICE = excluded.PRICE, 
    STORE_ID = excluded.STORE_ID
returning ID
/* batch-0: [Learning GraphQL, 3, 49.9, 2] */
/* batch-1: [GraphQL in Action, 3, 49.9, 2] */
/* batch-2: [LINQ in Action, 2, 39.9, 2] */
/* batch-3: [Kotlin in Action, 2, 39.9, 2] */
```

</td>
</tr>
</tbody>
</table>

:::info
If you are using MySQL, there are two points to note:

- Unlike Postgres which can explicitly specify columns used for determining data existence through `on conflict(NAME, EDITION)`,
  MySQL is special in that its `on duplicate key` cannot explicitly specify which columns are used for determining data existence.

  Therefore, when an `insert ... on duplicate key` statement doesn't insert the id field, MySQL will determine data existence based on all fields participating in unique constraints, even if these fields belong to multiple different unique constraints.

  Thus, you must add an additional parameter `noMoreUniqueConstraints` to the annotation, like:
  ```java
  @KeyUniqueConstraint(noMoreUniqueConstraints = true)
  ```
  `noMoreUniqueConstraints = true` tells Jimmer that the table corresponding to the entity has only one unique constraint *(or unique index)*.
  Users need to be responsible for their commitment.

- The SQL generated for MySQL includes:
  ```sql
  /* fake update to return all ids */ ID = last_insert_id(ID)
  ```    
  This is a relatively tricky technique. If the data is updated, it returns the existing id of the updated data; otherwise, it returns the id assigned by the database for automatically inserted data.
:::

Apart from utilizing the database's native UPSERT capabilities, the functionality is exactly the same as the previous example, and the printed result will not change at all, as shown below:

```
[3, 12, 100, 101]
```   

Where:
- 3 and 12 represent the ids of updated data
- 100 and 101 represent new ids assigned by the database for inserted data

## INSERT_IF_ABSENT

To be continued

## NON_IDEMPOTENT_UPSERT

To be continued