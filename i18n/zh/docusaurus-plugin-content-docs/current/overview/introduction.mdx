---
sidebar_position: 1
title: 项目介绍
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

import { ViewMore } from '@site/src/components/ViewMore';
import { DtoExplosion, ObjectCache, AssociationCache, CalculatedCache, MultiViewCache } from "@site/src/components/Image";
import { ObjectFetcherPanel } from '@site/src/components/HomepageFeatures/ObjectFetcher';
import { CommunicationPanel } from '@site/src/components/HomepageFeatures/Communication';
import DynamicShape from '../_shared/dynamic-shape.mdx';
import ImmutableStep from '../_shared/immutable-step.mdx';
import Entity from './_entity.mdx';
import Unloaded from './_unloaded.mdx';
import DTO from './_dto.mdx'; 
import Fetcher from './_fetcher.mdx'; 

## 1. 概述

Jimmer是一个Java/Kotlin双语框架

-   包含一个革命性的ORM

-   以此ORM为基础打造了一套综合性方案解决方案，包括

    -   DTO语言
    -   更全面更强大的缓存机制，以及缓存一致性的全自动维护
    -   更强大客户端文档和代码生成能力，包括Jimmer独创的远程异常
    -   快速创建GraphQL服务
    -   跨越微服务的远程实体关联

## 2. ORM部分

或许有人认为，访问关系型数据库技术栈已经固化多年，不会有什么变动。即使有新解决方案出现，也是重新制造轮子。所以，只需关注一些当前时髦的新技术体系即可，并坚信这个领域不会再有突破。

### 现有痛点

然而，事实上，当前技术生态下，访问关系型数据库技术体系存在很大缺陷，请看下图。

![mirror](@site/static/img/cmp.svg)

1.  以JPA为代表的静态语言ORM

    -   优点：便捷，代码安全*(本身基于强类型语言，大部分代码是安全的。如果结合QueryDSL使用，则可以保证所有代码都是安全的)*

    -   缺点：缺乏灵活性

        -   即使JPA从2.1开始支持EntityGraph，查询的灵活度仍然非常有限。该方案粒度仍然太粗，控制能力远没GraphQL这类技术的细腻。

        -   保存对象时，细节行为受普通属性的`insertable`、`updateable`和关联属性的`cascade`配置的控制，这类配置在实体类型中被硬编码固化，被保存的数据结构的格式无法变化，没有灵活性。

        -   如果要发挥ORM的优势，就必须查询很多属性；如果只想查询一部分属性，就必须放弃对象型查询，丧失ORM本该有的便捷性和核心价值。

2.  以为ActiveRecord *(Ruby)* 为代表的动态语言ORM

    -   优点：基于动态语言的ORM，只需将动态语言对象结构的灵活性和ORM的实现结合起来，就能兼顾便捷和灵活。

    -   缺点：动态语言虽然既然便捷又灵活，但是代码缺乏可维护性且不利于多人协同开发是众所周知的缺点。

        现代软件往往是复杂的，需要团队协作来完成，是否利于团队成员之间协同，远比个人对编程的认知重要。

        这里，不想过多地讨论动静之争，但是有一点需要指出：既然选择了静态语言Java/Kotlin，就应该以静态语言的方式使用它们，
        而不是使用以jFinal为代表的将静态语言当成动态语言用的方案，甚至在应用中频繁地使用`java.util.Map`来代替数据对象。
        这类做法违背了选择Java/Kotlin的初衷，如果一定要怎么做，为什么不直接选动态语言呢？

3.  以MyBatis为代表的轻量级SQL Builder/Mapper

    -   优点：直接编写SQL，随意且灵活；本身是强类型框架，具有代码安全性 *(MyBatis生态也有SQL DSL扩展，可以解决Native SQL字符串导致的代码不安全问题)*

    -   缺点：便捷性的严重缺失，重复劳动量极大。 

        MyBatis没有统一实体的概念，而是直接处理查询结果和各业务场景DTO。由于业务场景多，各DTO类型之间相似却不同，冗余度很高，导致重复劳动量极高。
        
        除了主要针对孤单对象的原生SQL的基本CRUD外，对多个对象彼此关联而成的复杂数据结构缺乏更多必要抽象，导致太多繁重的任务被推卸给开发人员 
        *(不少开发人员长期被这类繁重的任务所累，但自己一直没察觉)*。

    :::info
    最后，这个派别最引以为豪的观点是："直接书写SQL会带来更直接的控制力，这种直接控制力的优于任何ORM"。在这个领域长期的技术停滞中，不少开发人员对此深信不疑。
    然而，本文的后续内容专门对此为此准备一个惊喜，来改变这个根深蒂固的认知。
    :::

### 根本原因

上文中，我们阐述了关系型数据库领域的三种常见方案，但无论如何选者，我们都无法兼顾便捷性、灵活性和代码安全性。为什么会导致这样呢？

就JVM生态而言，POJO是导致这个问题的根本原因。POJO*(也可以叫结构体)*缺乏必要的灵活性和表达力，却被几乎被所有的JVM框架作为数据模型和核心，严重限制了JVM生态的技术创新。

因此，在Jimmer中，ORM实体对象并非POJO。这种神秘的实体对象撑起了Jimmer所有上层重大的变革，是整个框架的基石。

:::info
事实上，Jimmer实体度对象不仅可以应用在ORM领域，它几乎可以用在任何以结构化数据维护为目的的场景提升各种技术栈的表达力。
目前，Jimmer实体仅在关系型数据库访问领域发挥作用只是因为笔者的精力不够所致。
:::

## 3. 完整的功能

在本开开头我们提到了，革命性的ORM只是Jimmer的一部分，Jimmer实际的能力范围早已超越了一个ORM。

现在，我们给出Jimmer的功能示意图，并逐个讲解

![mirror](@site/static/img/features.svg)

### 3.1. Business Model

在信息类系统中，存在两种对象。

-   实体：实体对象是全局统一的，对象之间的存在丰富彼此关联。

    实体对象往往和数据库非常接近，具备极高的稳定性。

-   DTO：针对特定业务的输入/输出对象，通常是从全局实体关系网上撕下来的一个局部碎片，该碎片的大小和形状非常灵活。

    因此DTO类型数量庞大，每一种的格式都是千变万化，彼此可能相似但有不同，具备明显的<ViewMore buttonText="DTO爆炸问题"><DtoExplosion/></ViewMore>。而且易受到需求变化的影响，不稳定。

:::tip
Entity类型集全局统一，不易被需求变更影响，相对稳定，被视为高价值信息。而DTO类型集作为每个业务输入/输出，相对凌乱，容易因需求变动而不稳定，被视为低价值信息。

Jimmer要求开发人员把绝大部分精力集中在高价值的实体设计上；对于低价值的DTO类型，有时并不需要，即使需要，也可以用极其廉价的方式自动生成。因此，基于Jimmer构建的项目明显的抗需求变动的能力。
:::

#### 3.1.1. Jimmer Entity

Jimmer实体定义和JPA实体很接近。<ViewMore buttonText="查看快捷示范" title="实体定义"><Entity/></ViewMore>

之前讨论过，Jimmer实体并非POJO，所以，被声明为`interface`，而非`class`。

那么，谁负责实现此接口呢？是上图中的`Jimmer Precompiler`
*(对于Java而言，就是[APT](https://www.jetbrains.com/help/idea/annotation-processors-support.html)；
对于Kotlin而言，就是[KSP](https://kotlinlang.org/docs/ksp-overview.html))*

Jimmer实体支持两个重要特征，动态性和不可变性

-   动态性

    Jimmer对象在静态语言和动态语言之间寻求最佳平衡，把二者的有点结合起来：

    -   静态语言数据对象的高性能、拼写安全、类型安全、甚至空安全*(如果使用Kotlin的话)*

    -   动态语言数据对象的灵活性，Jimmer对象的每个属性都可以缺失

        > 对Jimmer而言，对象缺少某个属性 *(其值未知)* 和 对象的某个属性为null *(其值已知)* 是完全不同的两回事。  

    :::tip
    这种平衡设计，可以在享受静态语言好处的同时，为数据结构赋予<ViewMore buttonText="极大的灵活性" title="Jimmer实体的灵活性"><DynamicShape/></ViewMore>。

    这种绝对的灵活性，既可用于表达查询业务的输出格式，也可用于表达保存业务的输入格式。
    
    这导致Jimmer拥有全新的定位：一个为任意形状数据结构设计的ORM，其所有功能都是为了操作任意复杂的数据结构，而非具体的某个实体对象。
    :::

-   不可变性

    Jimmer对象是不可变对象。不可变对象的好处的多方面的，相关文章和论述非常多，本文不做重复性讨论。

    :::tip
    Jimmer选择不可变对象是为了让数据结构绝不包含[循环引用](https://en.wikipedia.org/wiki/Circular_reference)。
    
    这可以保证数据结构一定能够被直接Jackson序列化，并不需要使用诡异的序列化技巧为JSON植入任何特殊的额外信息，任何编程语言都可以轻松理解。
    :::

    然而，不可变对象也存在缺点。如果现有的一个很深的数据结构，那么基于它按照一些修改的愿望创建出新的数据结构会很困难，难度随着深度的变大急剧增加。*(究竟有多痛苦？若有兴趣，请参见[这里](http://localhost:3000/jimmer-doc/zh/docs/object/immutable/current-situation))*

    -   ORM和很深的数据结构打交道，而Java的record和Kotlin的data class不适合处理很深数据结构。

    -   JVM生态下没有既同时适用于Java和Kotlin又善于基于复杂结构按照一些修改的愿望创建出新的数据结构的方案。

    幸运的是，`JavaScript/TypeScript`领域存在一个足够强大的方案: [immer](https://github.com/immerjs/immer)，可以完美解决这个问题。该方案工作方式如下
    
    1.  为现有不可变数据结构开启一个临时作用域。

    2.  在这个作用域内，开发人人员可得到一个draft数据结构，该数据结构的形状和初始值和原数据结构完全一致，且可以被随意修改任意深的对象。
    
    3.  作用域结束后，draft数据结构会利用收集到的修改行为创建另外一个新的数据结构。其中，未被修改的局部会被优化处理，复用以前的旧对象。

    此方案完美结合了不可变对象和可变对象的有点，代码简单，执行效率高，因此Jimmer选者移植immer，项目名称也是对其致敬。<ViewMore buttonText="查看例子" title="从immer移植而来的不可变对象"><ImmutableStep/></ViewMore>

#### 3.1.2. Generated DTO Type

前文谈到，Jimmer实体是在静态语言和动态语言数据对象之间寻找最佳平衡，其中动态性带来了极大的灵活性，并以此决定了整个框架的定位。

Jimmer对象允许某些属性缺失，对象缺少某个属性 *(其值未知)* 和 对象的某个属性为null *(其值已知)* 是完全不同的两回事。

1.  对于Jackson序列化而言，缺失的属性会被自动忽略，就如同我们之前展示的那样。

    如果服务端自己并不使用查询得到实体对象，而是直接写入到Http Response中。对于这种情况，无需DTO，直接使用实体对象很方便。

2.  如果直接用Java/Kotlin代码访问不存在的属性，会导致异常。<ViewMore buttonText="查看快捷示范"><Unloaded/></ViewMore>

    如果服务端自己要使用查询得到实体对象，这会带来风险，尽管Jimmer实体在其他方面依旧保留了静态语言的特色，比如拼写安全、类型安全、甚至空安全*(如果使用kotlin)*。

    > 以JPA为例，从Hibernate3开始，lazy配置不再局限于关联属性，而是可以用于任何属性，包括标量属性。后来演化为JPA之`@Basic`注解的`fetch`参数，
    > 请参考这[这里](https://docs.oracle.com/javaee%2F7%2Fapi%2F%2F/javax/persistence/Basic.html)。
    >
    > 这和Jimmer对象任何属性都可以缺失有一定相似性。所以，Jimmer的这个异常和[org.hibernate.LazyIntializationException](https://docs.jboss.org/hibernate/orm/5.6/javadocs/org/hibernate/LazyInitializationException.html)有一定相似性。
    
    所以，这并非Jimmer引入的问题，而是一个在静态语言ORM生态中早已存在和被接受的问题。然而，不可否认这的确对静态语言的安全性形成了破坏。

    如果要追求100%的静态语言安全性，使用`DTO`对象是唯一的方法。然而，目前JVM生态的DTO映射技术存在很大缺陷。
    -   要么显式地映射属性，导致工作量巨大。
    -   要么隐式地映射属性*(例如采用[BeanUilts](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/beans/BeanUtils.html)技术)*，引入新的不安全问题。
    
    即使你使用强大的[mapstruct](https://mapstruct.org/)，你所能做也只是在这两个极端之间作出选择而已。

    因此，Jimmer提供了DTO语言，用户使用该语言编写非常简单的代码，编译项目即可自动生成各种丰富的DTO类型定义。

    :::tip
    DTO语言的设计目的，在于

    -   让生成DTO类型的的过程足够简单，从而让DTO类型足够廉价

    -   100%符合静态语言安全性，在编译时发现所有问题并报错。   
    :::

    在任何子项目中 *(并不限制为实体定义子项目)*，开发人员可以在`src/main/dto`目录下随意建立扩展名为`dto`的文件，
    廉价地方自动生成各种DTO类型。<ViewMore buttonText="查看快捷示范" title="DTO语言展示"><DTO/></ViewMore>

    这种以极低成本快速生成的DTO类型可以和Jimmer实体对象彼此转换；因此，任何两种DTO类型都可以以Jimmer实体为中间媒介彼此转换。

### 3.2. Fetcher

:::tip
Fetcher是Jimmer三个最基础的核心功能之一 *(另外两个是Save Command和SQL DSL)*。

Jimmer为查询任意形状的数据结构而设计，能像[GraphQL](https://graphql.org/)那样细腻地控制被查询数据的格式。
:::

1.  首先，通过这个动画来感受一下Jimmer随意控制被查询数据结构形状的能力 
    *(建立初步印象即可，不用看得太细)*。 <ViewMore buttonText="查看动画" title="Fetcher初步印象"><ObjectFetcherPanel/></ViewMore>

2.  前文提到，既可以直接使用实体对象，也可以使用被廉价生成的DTO对象。Fetcher对这两种数据对象的查询都提供了一流的支持。<ViewMore buttonText="查看快捷示范" maxWidth="lg"><Fetcher/></ViewMore>**（重要)**

    :::info
    用户应该积极地使用该功能查询任意复杂的数据结构，而非自己编写业务代码去获取不同部分的数据再拼接成一个整体，因为Fetcher具有如下很难用业务代码替代的优势：

    -   不但能处理关联属性，还能处理[复杂计算属性](../mapping/advanced/calculated/transient)
    -   能充分利用的Jimmer的<ViewMore buttonText="关联缓存" variant="text"><AssociationCache/></ViewMore>
        和<ViewMore buttonText="计算缓存" variant="text"><CalculatedCache/></ViewMore>大幅优化复杂数据结构的查询能力
    -   实体支持[远程关联](../spring/spring-cloud)，即使，跨越微服务边界的ORM关联，Jimmer自动从不同的微服务查询数据组装成一个数据结构
    -   整个层层深入的过程由广度递归驱动，以支持批量查询优化
    :::

无需开发人员做任何工作，ORM本身就具备了可媲美GraphQL的强大能力。所以，无论用Jimmer来构建REST服务，还是GraphQL服务，查询相关任务都非常简单。

-   快速构建REST服务

    由服务端控制返回对象的形状。如果某个HTTP API需要返回的数据结构形状是什么，开发人员都有两种选择：直接使用实体类型，或用DTO语言廉价地生成DTO类型。
    
    无论如何选择，客户端都是被动地接受服务端返回的数据格式。即使，客户端需要的数据结构形状种类非常多，对基于Jimmer开发的服务端影响很小。

    > 如果想由客户端控制返回对象的形状，你应该考虑构建GraphQL服务。

    如果某个HTT API查询数据的目的只是为写入Http Reponse，开发人员可以选择直接返回实体对象。这时服务端没有<ViewMore buttonText="DTO爆炸问题" variant="text"><DtoExplosion/></ViewMore>，
    这对服务端不是问题；但是对于客户端而言，这时非常糟糕的。

    Jimmer为客户端生成Open Api文档和TypeScript代码 *(RPC风格)*，如果服务端开发人员选择直接返回实体对象，
    则可通过`@FetchBy`注解在Open Api和TypeScript代码中定义DTO类型。<ViewMore buttonText="客户端DTO"><CommunicationPanel/></ViewMore>

-   快速构建GraphQL服务

    通常情况下，提供GraphQL服务工作量不小，开发人员要花很大的精力去支持GraphQL对象之间丰富的关联。

    然而，基于Jimmer实现GraphQL是非常容易的，因为ORM本身已经有了和GraphQL类似的能力，开发人员只需为GraphQL查询API实现聚合根对象的查询即可，GraphQL对象之间丰富的关联由Jimmer自动实现。

参考链接

|链接|描述|
|---|---|
|[快速预览/查询任意形状](../quick-view/fetch)|Fetcher功能点概述|
|[jimmer-examples/tree/main/java/jimmer-sql](https://github.com/babyfish-ct/jimmer-examples/tree/main/java/jimmer-sql)|例子项目，使用Java和Jimmer构建REST服务|
|[jimmer-examples/tree/main/java/jimmer-sql-kt](https://github.com/babyfish-ct/jimmer-examples/tree/main/java/jimmer-sql-kt)|例子项目，使用Kotlin和Jimmer构建REST服务|
|[jimmer-examples/tree/main/java/jimmer-sql-graphql](https://github.com/babyfish-ct/jimmer-examples/tree/main/java/jimmer-sql-graphql)|例子项目，使用Java和Jimmer构建GraphQL服务|
|[jimmer-examples/tree/main/java/jimmer-sql-graphql-kt](https://github.com/babyfish-ct/jimmer-examples/tree/main/java/jimmer-sql-graphql-kt)|例子项目，使用Kotlin和Jimmer构建GraphQL服务|

### 3.3. Save Command