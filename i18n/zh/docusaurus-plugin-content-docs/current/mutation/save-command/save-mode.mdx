---
sidebar_position: 3
title: 根对象保存模式
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import Key from '../../_shared/key.mdx';
import { ViewMore } from '@site/src/components/ViewMore';

## 保存模式

保存指令支持5种保存模式，控制聚合根本身的保存方式

-   UPSERT: 这是默认的模式。先通过查询判断被保存的聚合根对象是否存在：

    -   如果不存在：执行INSERT语句

    -   如果存在：执行UPDATE语句

-   INSERT_ONLY: 无条件执行INSERT语句

-   INSERT_IF_ABSENT: 

    -   如果数据已经存在，忽略操作
    
    -   否则，插入数据

-   UPDATE_ONLY: 无条件执行UPDATE语句

-   NON_IDEMPOTENT_UPSERT: 

    -   如果对象的@Id属性或@Key属性被指定，执行与UPSERT等价的行为

    -   否则，执行INSERT操作

    :::note
    此行为和JPA的`merge`或Hibernate的`saveOrUpdate`等价，但是，在Jimmer中并不被推荐。
    :::

:::caution
保存模式仅影响聚合根对象，不影响其他关联对象。

对于关联对象而言，请参考[关联对象保存模式](./associated-save-mode)。
:::

## INSERT_ONLY

`INSERT_ONLY`表示无条件插入数据

<Tabs groupId="language">
<TabItem value="java" label="Java">

```java
List<Book> books = Arrays.asList(
    Immutables.createBook(draft -> {
        draft.setName("SQL in Action");
        draft.setEdition(3);
        draft.setPrice(new BigDecimal("49.9"));
        draft.setStoreId(2L);
    }),
    Immutables.createBook(draft -> {
        draft.setName("LINQ in Action");
        draft.setEdition(2);
        draft.setPrice(new BigDecimal("39.9"));
        draft.setStoreId(2L);
    })
);

List<Long> allocatedIds = sqlClient    
    .saveEntities(
        books, 
        // highlight-next-line
        SaveMode.INSERT_ONLY
    )
    .getItems()
    .stream()
    .map(item -> item.getModifiedEntity().id())
    .collect(Collectors.toList());

System.out.println("Allocated ids: " + allocatedIds);
```

</TabItem>
<TabItem value="kotlin" label="Kotlin">

```kotlin
val books = listOf(
    Book {
        name = "SQL in Action"
        edition = 3
        price = BigDecimal("49.9")
        storeId = 2L
    },
    Book {
        name = "SQL in Action"
        edition = 2
        price = BigDecimal("39.9")
        storeId = 2L
    }
)

val allocatedIds = sqlClient
    .saveEntities(
        books,
        // highlight-next-line
        SaveMode.INSERT_ONLY
    )
    .items
    .map {
        it.modifiedEntity.id
    }

println("Allocated ids: $allocatedIds")
```

</TabItem>
</Tabs>

INSERT_ONLY的工作方式非常简单，不做任何判断，无条件插入。

生成的批量操作SQL如下

```sql
insert into BOOK(NAME, EDITION, PRICE, STORE_ID) values(?, ?, ?, ?)
/* batch-0: SQL in Action, 3, 49.9, 2 */
/* batch-1: [LINQ in Action, 2, 39.9, 2 */
```

这个例子中，由于id属性对应的列采用了数据自动编号。因此批量插入完成后，数据库为所有数据分配的id都将被返回，打印结果为

```
Allocated ids: [100, 101]
```

## UPDATE_ONLY

`INSERT_ONLY`表示无条件更新数据，分为两种情况

-   对于Id-Specified对象而言，按照id修改数据

-   对于制定Key-Specified而言，按照key修改数据

### 按照id更新数据

<Tabs groupId="language">
<TabItem value="java" label="Java">

```java
List<Book> books = Arrays.asList(
    Immutables.createBook(draft -> {
        draft.setId(3L); // Matched
        draft.setName("SQL in Action");
        draft.setEdition(3);
        draft.setPrice(new BigDecimal("49.9"));
        draft.setStoreId(2L);
    }),
    Immutables.createBook(draft -> {
        draft.setId(100L); // Not matched
        draft.setName("LINQ in Action");
        draft.setEdition(2);
        draft.setPrice(new BigDecimal("39.9"));
        draft.setStoreId(2L);
    })
);
BatchSaveResult<Book> result = sqlClient
    .saveEntities(
        books,
        // highlight-next-line
        SaveMode.UPDATE_ONLY
    );
System.out.println("Affected row count: " + result.getTotalAffectedRowCount());
```

</TabItem>
<TabItem value="kotlin" label="Kotlin">

```kotlin
val books = listOf(
    Book {
        id = 3L
        name = "SQL in Action"
        edition = 3
        price = BigDecimal("49.9")
        storeId = 2L
    },
    Book {
        id = 100L
        name = "SQL in Action"
        edition = 2
        price = BigDecimal("39.9")
        storeId = 2L
    }
)
val result = sqlClient
    .saveEntities(
        books,
        // highlight-next-line
        SaveMode.UPDATE_ONLY
    )

println("Affected row count: ${result.totalAffectedRowCount}")
```

</TabItem>
</Tabs>

对象的id属性被指定，因此根据对象的id来更新对象，生成的批量操作SQL如下

```
update BOOK
set
    NAME = ?,
    EDITION = ?,
    PRICE = ?,
    STORE_ID = ?
where
    ID = ?
/* batch-0: [SQL in Action, 3, 49.9, 2, 3] *
/* batch-1: [LINQ in Action, 2, 39.9, 2, 100] */
```

该批量操作修改企图两条数据，假设数据库只有一条匹配数据，打印结果为`1`。

### 按照key更新数据

假设Book实体定义如下 

<Tabs groupId="language">
<TabItem value="java" label="Java">

```java title="Book.java"
@Entity
public interface Book {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    long id();

    // highlight-next-line
    @Key
    String name();

    // highlight-next-line
    @Key
    int edition();

    ...省略其他既非id也非key的属性...
}
```

</TabItem>
<TabItem value="kotlin" label="Kotlin">

```kotlin title="Book.kt"
@Entity
public interface Book {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    val id: Long

    // highlight-next-line
    @Key
    val name: String

    // highlight-next-line
    @Key
    val edition: Int

    ...省略其他既非id也非key的属性...
}
```

</TabItem>
</Tabs>

这里`Book.name`和`Book.edition`被[@Key](../../mapping/advanced/key)修饰。

<Tabs groupId="language">
<TabItem value="java" label="Java">

```java
List<Book> books = Arrays.asList(
    Immutables.createBook(draft -> {
        // Id is not specified
        draft.setName("Learning GraphQL");
        draft.setEdition(3);
        draft.setPrice(new BigDecimal("49.9"));
        draft.setStoreId(2L);
    }),
    Immutables.createBook(draft -> {
        // Id is not specified
        draft.setName("LINQ in Action");
        draft.setEdition(2);
        draft.setPrice(new BigDecimal("39.9"));
        draft.setStoreId(2L);
    })
);
BatchSaveResult<Book> result = sqlClient
    .saveEntities(
        books,
        // highlight-next-line
        SaveMode.UPDATE_ONLY
    );
for (MutationResultItem<Book> item : result.getItems()) {
    if (ImmutableObjects.isLoaded(item.getModifiedEntity(), BookProps.ID)) {
        System.out.println("Data is updated, updated id is " + item.getModifiedEntity().id());
    } else {
        System.out.println("Data is not updated");
    }
}
```

</TabItem>
<TabItem value="kotlin" label="Kotlin">

```kotlin
val books = listOf(
    Book {
        // Id is not specified
        name = "Learning GraphQL"
        edition = 3
        price = BigDecimal("49.9")
        storeId = 2L
    },
    Book {
        // Id is not specified
        name = "SQL in Action"
        edition = 2
        price = BigDecimal("39.9")
        storeId = 2L
    }
)
val result = sqlClient
    .saveEntities(
        books,
        // highlight-next-line
        SaveMode.UPDATE_ONLY
    )
for (item in result.item) {
    if (isLoaded(item.modifiedEntity, Book::id)) {
        println("Data is updated, updated id is ${item.isModified}")
    } else {
        println("Data is not updated")
    }
}
```

</TabItem>
</Tabs>

对象的id属性没有指定，因此根据对象的key来更新对象，生成的批量操作SQL如下

```
update BOOK
set
    PRICE = ?,
    STORE_ID = ?
where
    NAME = ?
    and
    EDITION = ?
/* batch-0: [49.9, 2, Learning GraphQL, 3] */
/* batch-1: [39.9, 2, LINQ in Action, 2] */
```

打印结果为

```
Data is updated, updated id is 3
Data is not updated
```

## UPSERT

`UPSERT`表示先判断数据是否存在，如果存在则更新，否则即插入

-   对于Id-Specified对象而言，按照id判断数据是否存在，再决定INSERT或UPDATE

-   对于制定Key-Specified而言，按照key判断数据是否存在，再决定INSERT或UPDATE

### 按照Id判断数据是否存在

<Tabs groupId="language">
<TabItem value="java" label="Java">

```java
List<Book> books = Arrays.asList(
    Immutables.createBook(draft -> {
        draft.setId(3L);
        draft.setName("Learning GraphQL");
        draft.setEdition(3);
        draft.setPrice(new BigDecimal("49.9"));
        draft.setStoreId(2L);
    }),
    Immutables.createBook(draft -> {
        draft.setId(90L);
        draft.setName("LINQ in Action");
        draft.setEdition(2);
        draft.setPrice(new BigDecimal("39.9"));
        draft.setStoreId(2L);
    })
);

sqlClient
    .saveEntities(
        books,
        // highlight-next-line
        SaveMode.UPSERT
    );
```

</TabItem>
<TabItem value="kotlin" label="Kotlin">

```kotlin
val books = listOf(
    Book {
        id = 3L
        name = "Learning GraphQL"
        edition = 3
        price = BigDecimal("49.9")
        storeId = 2L
    },
    Book {
        id = 90L
        name = "SQL in Action"
        edition = 2
        price = BigDecimal("39.9")
        storeId = 2L
    }
)
sqlClient.save(
    books,
    // highlight-next-line
    SaveMode.UPSERT
)
```

</TabItem>
</Tabs>

Jimmer会优先使用数据库本身的能力进行UPSERT操作，因此，会为不同的数据库生成不同的SQL

<table>
<thead>
<tr>
<th>数据库</th>
<th>生成的SQL</th>
</tr>
</thead>
<tbody>
<tr>
<td>H2</td>
<td>

```sql
merge into BOOK(
    ID, NAME, EDITION, PRICE, STORE_ID
) key(ID) values(
    ?, ?, ?, ?, ?
)
/* batch-0: [3, Learning GraphQL, 3, 49.9, 2] */
/* batch-1: [90, LINQ in Action, 2, 39.9, 2] */
```

</td>
</tr>
<tr>
<td>MySQL</td>
<td>

```sql
insert into BOOK(
    ID, NAME, EDITION, PRICE, STORE_ID
) values(?, ?, ?, ?, ?)
on duplicate key update 
    NAME = values(NAME), 
    EDITION = values(EDITION), 
    PRICE = values(PRICE), 
    STORE_ID = values(STORE_ID)
/* batch-0: [3, Learning GraphQL, 3, 49.9, 2] */
/* batch-1: [90, LINQ in Action, 2, 39.9, 2] */
```

</td>
</tr>
<tr>
<td>Postgres</td>
<td>

```sql
insert into BOOK(
    ID, NAME, EDITION, PRICE, STORE_ID
) values(?, ?, ?, ?, ?)
on conflict(ID) do update set
    NAME = excluded.NAME, 
    EDITION = excluded.EDITION, 
    PRICE = excluded.PRICE, 
    STORE_ID = excluded.STORE_ID)
/* batch-0: [3, Learning GraphQL, 3, 49.9, 2] */
/* batch-1: [90, LINQ in Action, 2, 39.9, 2] */
```

</td>
</tr>
</tbody>
</table>

### 按照Key判断数据是否存在

如果不指定对象的id，例如

<Tabs groupId="language">
<TabItem value="java" label="Java">

```java
List<Book> books = Arrays.asList(
    Immutables.createBook(draft -> {
        draft.setName("Learning GraphQL");
        draft.setEdition(3);
        draft.setPrice(new BigDecimal("49.9"));
        draft.setStoreId(2L);
    }),
    Immutables.createBook(draft -> {
        draft.setName("GraphQL in Action");
        draft.setEdition(3);
        draft.setPrice(new BigDecimal("49.9"));
        draft.setStoreId(2L);
    }),
    Immutables.createBook(draft -> {
        draft.setName("LINQ in Action");
        draft.setEdition(2);
        draft.setPrice(new BigDecimal("39.9"));
        draft.setStoreId(2L);
    }),
    Immutables.createBook(draft -> {
        draft.setName("Kotlin in Action");
        draft.setEdition(2);
        draft.setPrice(new BigDecimal("39.9"));
        draft.setStoreId(2L);
    })
);
List<Long> ids = sqlClient
    .saveEntities(
        books,
        // highlight-next-line
        SaveMode.UPSERT
    )
    .getItems()
    .stream().map(it -> it.getModifiedEntity().id())
    .collect(Collectors.toList());
System.out.println(ids);
```

</TabItem>
<TabItem value="kotlin" label="Kotlin">

```kotlin
val books = listOf(
    Book {
        name = "Learning GraphQL"
        edition = 3
        price = BigDecimal("49.9")
        storeId = 2L
    },
    Book {
        name = "GraphQL in Action"
        edition = 3
        price = BigDecimal("49.9")
        storeId = 2L
    },
    Book {
        name = "SQL in Action"
        edition = 2
        price = BigDecimal("39.9")
        storeId = 2L
    },
    Book {
        name = "Kotlin in Action"
        edition = 2
        price = BigDecimal("39.9")
        storeId = 2L
    }
)
val ids = sqlClient.save(
    books,
    // highlight-next-line
    SaveMode.UPSERT
).items.map{ it.id }
println(ids)
```

</TabItem>
</Tabs>

默认情况下，Jimmer会尽可能使用数据本身的UPSERT能力。

然而，目前这种情况下，做不到这一点 *(稍后我们马上讨论这个问题如何解决)*。

这时，Jimmer会先执行查询，然后根据查询结果来决定应该对那些数据进行INSERT，对那些数据生成UPDATE语句。共三条SQL语句

1. 查询，并给出原因
    ```sql
    /* highlight-next-line */
    Purpose: COMMAND(KEY_UNIQUE_CONSTRAINT_REQUIRED)
    SQL: select
        tb_1_.ID,
        tb_1_.NAME,
        tb_1_.EDITION
    from BOOK tb_1_
    where
        (tb_1_.NAME, tb_1_.EDITION) in (
            (? /* Learning GraphQL */, ? /* 3 */), 
            (? /* GraphQL in Action */, ? /* 3 */), 
            (? /* LINQ in Action */, ? /* 2 */), 
            (? /* Kotlin in Action */, ? /* 2 */)
        )
    ```

    :::info
    Jimmer在日志中打印了`KEY_UNIQUE_CONSTRAINT_REQUIRED`，这个值叫做QueryReason。

    Jimmer优先考虑利用数据库本身的UPSERT能力，如果无法做到导致了查询语句，会给出QueryReason，以帮助用户调查和寻找解决方案。
    :::

2.  对不存在的数据进行插入操作

    ```sql
    insert into BOOK(
        NAME, EDITION, PRICE, STORE_ID
    ) values(
        ?, ?, ?, ?
    )
    /* batch-0: [LINQ in Action, 2, 39.9, 2] */
    /* batch-1: [Kotlin in Action, 2, 39.9, 2] */
    ```

3.  对存在的数据进行更新操作

    ```sql
    update BOOK
    set
        PRICE = ?,
        STORE_ID = ?
    where
        ID = ?
    /* batch-0: [49.9, 2, 3] */
    /* batch-1: [49.9, 2, 12] */
    ```

打印结果如下

```
[3, 12, 100, 101]
```   
其中
-   3和12表示被更新的数据id
-   100和101表示数据库为被插入数据分配的新id

### 改进后的按Key判断

在上个例子中，Jimmer执行了查询，并给出了QueryReason `KEY_UNIQUE_CONSTRAINT_REQUIRED`。

Jimmer为所有的QueryReason提供了详尽的文档注释，详情请参见[QueryReason](https://github.com/babyfish-ct/jimmer/blob/main/project/jimmer-sql/src/main/java/org/babyfish/jimmer/sql/ast/mutation/QueryReason.java)。

就这里的`KEY_UNIQUE_CONSTRAINT_REQUIRED`而言，表示需要

1.  为`Book.name`和`Book.edition`属性建立唯一性约束，即

    ```sql
    alter table book
        add constraint uq_book__name_edition
            /* highlight-next-line */
            unique(name, edition);
    ```

    这是因为数据库的UPSERT功能依赖于唯一约束 *(或唯一索引)*

2.  通过`@KeyUniqueConstraint`注解告诉Jimmer，被`@Key`修饰的属性在数据库中存在对于的唯一约束 *(或唯一索引)*

    <Tabs groupId="language">
    <TabItem value="java" label="Java">

    ```java title="Book.java"
    @Entity
    // highlight-next-line
    @KeyUniqueConstraint
    public interface Book {

        @Id
        @GeneratedValue(strategy = GenerationType.IDENTITY)
        long id();

        @Key
        String name();

        @Key
        int edition();

        ...省略其他既非id也非key的属性...
    }
    ```

    </TabItem>
    <TabItem value="kotlin" label="Kotlin">

    ```kotlin title="Book.kt"
    @Entity
    // highlight-next-line
    @KeyUniqueConstraint
    public interface Book {

        @Id
        @GeneratedValue(strategy = GenerationType.IDENTITY)
        val id: Long

        @Key
        val name: String

        @Key
        val edition: Int

        ...省略其他既非id也非key的属性...
    }
    ```

    </TabItem>
    </Tabs>

    :::caution
    对于MySQL而言，需要
    ```java
    @KeyUniqueConstraint(noMoreUniqueConstraints = true)
    ```
    :::

一旦完整这两点改进，再次执行上一个例子。Jimmer不在执行select语句，而是直接利用数据库本身的UPSERT能力

<table>
<thead>
<tr>
<th>数据库</th>
<th>生成的SQL</th>
</tr>
</thead>
<tbody>
<tr>
<td>H2</td>
<td>

```sql
merge into BOOK(
    NAME, EDITION, PRICE, STORE_ID
) key(
    /* highlight-next-line */
    NAME, EDITION
) values(
    ?, ?, ?, ?
)
/* batch-0: [Learning GraphQL, 3, 49.9, 2] */
/* batch-1: [GraphQL in Action, 3, 49.9, 2] */
/* batch-2: [LINQ in Action, 2, 39.9, 2] */
/* batch-3: [Kotlin in Action, 2, 39.9, 2] */
```

</td>
</tr>
<tr>
<td>MySQL</td>
<td>

```sql
insert into BOOK(
    NAME, EDITION, PRICE, STORE_ID
) values(?, ?, ?, ?)
on duplicate key update 
    /* fake update to return all ids */ ID = last_insert_id(ID), 
    NAME = values(NAME), 
    EDITION = values(EDITION), 
    PRICE = values(PRICE), 
    STORE_ID = values(STORE_ID)
/* batch-0: [Learning GraphQL, 3, 49.9, 2] */
/* batch-1: [GraphQL in Action, 3, 49.9, 2] */
/* batch-2: [LINQ in Action, 2, 39.9, 2] */
/* batch-3: [Kotlin in Action, 2, 39.9, 2] */
```

</td>
</tr>
<tr>
<td>Postgres</td>
<td>

```sql
insert into BOOK(
    NAME, EDITION, PRICE, STORE_ID
) values(?, ?, ?, ?, ?)
on conflict(
    /* highlight-next-line */
    NAME, EDITION
) do update set
    NAME = excluded.NAME, 
    EDITION = excluded.EDITION, 
    PRICE = excluded.PRICE, 
    STORE_ID = excluded.STORE_ID
returning ID
/* batch-0: [Learning GraphQL, 3, 49.9, 2] */
/* batch-1: [GraphQL in Action, 3, 49.9, 2] */
/* batch-2: [LINQ in Action, 2, 39.9, 2] */
/* batch-3: [Kotlin in Action, 2, 39.9, 2] */
```

</td>
</tr>
</tbody>
</table>

:::info
如果你在使用MySQL，以下两点需要注意

-   和Posgres能通过`on conflict(NAME, EDITION)`明确指定用于判断数据存在性的列不同，
    MySQL比较特殊，其`on duplicate key`无法明确制定指定用于判断数据存在性的列。

    因此，当`insert ... on duplicate key`语句不插入id字段时，MySQL会基于所有参与
    唯一性约束字段判断数据是否存在，即使这些字段隶属于多个不同的唯一性约束。

    因此，必须为注解添加额外的参数`noMoreUniqueConstraints`，即
    ```java
    @KeyUniqueConstraint(noMoreUniqueConstraints = true)
    ```
    `noMoreUniqueConstraints = true`告诉Jimmer，实体所对应的表只有一个唯一约束 *(或唯一索引)*。
    用户需对自己的承诺负责。

-   为MySQL所生成的SQL包含
    ```sql
    /* fake update to return all ids */ ID = last_insert_id(ID)
    ```    
    这是一个相对tricky的技巧。如果数据被更新，返回被更新数据的已有id；否则，返回数据库为自动插入的数据分配的id。
:::

除了利用数据库本身的UPSERT能力外，功能和上个例子完全一样，打印结果也不会有任何改变，如下

```
[3, 12, 100, 101]
```   

其中
-   3和12表示被更新的数据id
-   100和101表示数据库为被插入数据分配的新id

## INSERT_IF_ABSENT

稍后继续

## NON_IDEMPOTENT_UPSERT

稍后继续