"use strict";(self.webpackChunkdocusaurus_code=self.webpackChunkdocusaurus_code||[]).push([[8678],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>c});var a=n(67294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function l(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?l(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):l(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},l=Object.keys(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var s=a.createContext({}),d=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},p=function(e){var t=d(e.components);return a.createElement(s.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,l=e.originalType,s=e.parentName,p=o(e,["components","mdxType","originalType","parentName"]),u=d(n),c=i,k=u["".concat(s,".").concat(c)]||u[c]||m[c]||l;return n?a.createElement(k,r(r({ref:t},p),{},{components:n})):a.createElement(k,r({ref:t},p))}));function c(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var l=n.length,r=new Array(l);r[0]=u;var o={};for(var s in t)hasOwnProperty.call(t,s)&&(o[s]=t[s]);o.originalType=e,o.mdxType="string"==typeof e?e:i,r[1]=o;for(var d=2;d<l;d++)r[d]=n[d];return a.createElement.apply(null,r)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},85162:(e,t,n)=>{n.d(t,{Z:()=>r});var a=n(67294),i=n(34334);const l="tabItem_Ymn6";function r(e){let{children:t,hidden:n,className:r}=e;return a.createElement("div",{role:"tabpanel",className:(0,i.Z)(l,r),hidden:n},t)}},65488:(e,t,n)=>{n.d(t,{Z:()=>c});var a=n(83117),i=n(67294),l=n(34334),r=n(72389),o=n(67392),s=n(7094),d=n(12466);const p="tabList__CuJ",m="tabItem_LNqP";function u(e){var t;const{lazy:n,block:r,defaultValue:u,values:c,groupId:k,className:h}=e,N=i.Children.map(e.children,(e=>{if((0,i.isValidElement)(e)&&"value"in e.props)return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)})),g=c??N.map((e=>{let{props:{value:t,label:n,attributes:a}}=e;return{value:t,label:n,attributes:a}})),b=(0,o.l)(g,((e,t)=>e.value===t.value));if(b.length>0)throw new Error(`Docusaurus error: Duplicate values "${b.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`);const I=null===u?u:u??(null==(t=N.find((e=>e.props.default)))?void 0:t.props.value)??N[0].props.value;if(null!==I&&!g.some((e=>e.value===I)))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${I}" but none of its children has the corresponding value. Available values are: ${g.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);const{tabGroupChoices:f,setTabGroupChoices:y}=(0,s.U)(),[v,E]=(0,i.useState)(I),T=[],{blockElementScrollPositionUntilNextRender:S}=(0,d.o5)();if(null!=k){const e=f[k];null!=e&&e!==v&&g.some((t=>t.value===e))&&E(e)}const D=e=>{const t=e.currentTarget,n=T.indexOf(t),a=g[n].value;a!==v&&(S(t),E(a),null!=k&&y(k,String(a)))},O=e=>{var t;let n=null;switch(e.key){case"ArrowRight":{const t=T.indexOf(e.currentTarget)+1;n=T[t]??T[0];break}case"ArrowLeft":{const t=T.indexOf(e.currentTarget)-1;n=T[t]??T[T.length-1];break}}null==(t=n)||t.focus()};return i.createElement("div",{className:(0,l.Z)("tabs-container",p)},i.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,l.Z)("tabs",{"tabs--block":r},h)},g.map((e=>{let{value:t,label:n,attributes:r}=e;return i.createElement("li",(0,a.Z)({role:"tab",tabIndex:v===t?0:-1,"aria-selected":v===t,key:t,ref:e=>T.push(e),onKeyDown:O,onFocus:D,onClick:D},r,{className:(0,l.Z)("tabs__item",m,null==r?void 0:r.className,{"tabs__item--active":v===t})}),n??t)}))),n?(0,i.cloneElement)(N.filter((e=>e.props.value===v))[0],{className:"margin-top--md"}):i.createElement("div",{className:"margin-top--md"},N.map(((e,t)=>(0,i.cloneElement)(e,{key:t,hidden:e.props.value!==v})))))}function c(e){const t=(0,r.Z)();return i.createElement(u,(0,a.Z)({key:String(t)},e))}},32102:(e,t,n)=>{n.d(t,{s:()=>h});var a=n(83117),i=n(67294),l=n(42293),r=n(50657),o=n(6514),s=n(54776),d=n(10155),p=n(15861),m=n(93946),u=n(9137),c=n(61274),k=n(50594);const h=(0,i.memo)((e=>{let{open:t,fullScreen:n=!1,title:a,maxWidth:s="md",onClose:h,children:g}=e;const[b,I]=(0,i.useState)(n),f=(0,i.useCallback)((()=>{I((e=>!e))}),[]);return i.createElement(r.Z,{open:t,onClose:h,fullScreen:b,TransitionComponent:N,maxWidth:s},i.createElement(l.Z,{sx:{position:"relative"}},i.createElement(d.Z,null,i.createElement(p.Z,{sx:{ml:2,flex:1},variant:"h6",component:"div"},a),i.createElement(m.Z,{onClick:f,style:{color:"white"}},b?i.createElement(c.Z,null):i.createElement(u.Z,null)),i.createElement(m.Z,{"aria-label":"close",onClick:h,style:{color:"white"}},i.createElement(k.Z,null)))),i.createElement(o.Z,null,g))})),N=i.forwardRef((function(e,t){return i.createElement(s.Z,(0,a.Z)({direction:"up",ref:t},e))}))},39511:(e,t,n)=>{n.d(t,{b:()=>r});var a=n(67294),i=n(83321),l=n(32102);const r=(0,a.memo)((e=>{let{buttonText:t,fullScreen:n=!1,title:r=t,variant:o="outlined",large:s=!1,maxWidth:d,useOriginalText:p=!0,children:m}=e;const[u,c]=(0,a.useState)(!1),k=(0,a.useCallback)((e=>{c(!0),e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}),[]),h=(0,a.useCallback)((()=>{c(!1)}),[]),N=p?{textTransform:"none"}:{};return a.createElement(a.Fragment,null,a.createElement(i.Z,{"data-is-view-more-button":"true",onClick:k,variant:o,size:s?"large":"small",style:N},t),a.createElement(l.s,{open:u,onClose:h,title:r,maxWidth:d,fullScreen:n},m))}))},51873:(e,t,n)=>{n.d(t,{ZP:()=>s});var a=n(83117),i=(n(67294),n(3905)),l=n(65488),r=n(85162);const o={toc:[]};function s(e){let{components:t,...n}=e;return(0,i.kt)("wrapper",(0,a.Z)({},o,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Initially, people used business fields directly as the primary key of tables. This is the most straightforward and easy to use approach, but it has the following problems:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Unstable primary key"),(0,i.kt)("p",{parentName:"li"},"Since the primary key itself is a business field, it can be modified, which leads to an unstable primary key."),(0,i.kt)("p",{parentName:"li"},"Although the foreign keys that reference it in the database can use ",(0,i.kt)("inlineCode",{parentName:"p"},"on update cascade")," to keep consistency,\nan unstable primary key will cause many problems for systems outside the database, such as caches."),(0,i.kt)("p",{parentName:"li"},"Even if a unified solution to the primary key instability problem can be abstracted at the technical level, it is not recommended, because it makes the system difficult to understand.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"High cost of multi-table joins"),(0,i.kt)("p",{parentName:"li"},"Since the primary key itself is a business field, its type is likely to be a relatively long string type rather than a numeric type,\nand it may even be a composite primary key composed of multiple columns, which leads to high cost of multi-table joins."))),(0,i.kt)("p",null,"To solve the above problems, people learned to use data without business meaning as the primary key, such as"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Auto numbering by database"),(0,i.kt)("li",{parentName:"ul"},"Sequence value by database"),(0,i.kt)("li",{parentName:"ul"},"UUID"),(0,i.kt)("li",{parentName:"ul"},"Snowflake ID")),(0,i.kt)("p",null,"To enable idempotent saves for save commands, Jimmer introduces two concepts: Id and Key"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"@Id: Primary key")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"@Key: Business primary key"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"If Id itself is a business attribute (not recommended), no need to specify Key, because Id itself already represents the uniqueness constraint at the business level.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"If Id has no business meaning (recommended), then Key represents what the uniqueness constraint is at the business level."))))),(0,i.kt)("p",null,"See the following example:"),(0,i.kt)(l.Z,{groupId:"language",mdxType:"Tabs"},(0,i.kt)(r.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},'@Entity  \npublic interface TreeNode {\n\n    @Id  \n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    long id();\n\n    // highlight-next-line\n    @Key\n    String name();\n\n    // highlight-next-line \n    @Key  \n    @ManyToOne\n    @Nullable\n    TreeNode parent();\n\n    @OneToMany(mappedBy = "parent")\n    List<TreeNode> childNodes();\n}\n'))),(0,i.kt)(r.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-kotlin"},'@Entity\ninterface TreeNode {\n\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY) \n    val id: Long\n\n    // highlight-next-line\n    @Key\n    val name: String\n\n    // highlight-next-line\n    @Key   \n    @ManyToOne\n    val parent: TreeNode?\n\n    @OneToMany(mappedBy = "parent")\n    val childNodes: List<TreeNode>\n}\n')))),(0,i.kt)("p",null,"Here, the Id of the ",(0,i.kt)("inlineCode",{parentName:"p"},"TreeNode")," entity uses auto numbering and has no business meaning. Therefore, to better match save commands,\n",(0,i.kt)("inlineCode",{parentName:"p"},"key")," is specified here, consisting of two properties: ",(0,i.kt)("inlineCode",{parentName:"p"},"name")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"parent"),"."),(0,i.kt)("p",null,"The corresponding DDL is:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sql"},"create table TREE_NODE(\n    ID bigint not null,\n    NAME varchar(20) not null,\n    PARENT_ID bigint\n);\n\nalter table TREE_NODE\n    add constraint PK_TREE_NODE\n        primary key(ID);\n        \nalter table TREE_NODE\n    add constraint UQ_TREE_NODE\n        /* highlight-next-line */\n        unique(NAME, PARENT_ID); \n")),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"name")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"parent")," properties of the entity type decorated with @Key correspond to the UNIQUE constraint ",(0,i.kt)("em",{parentName:"p"},"(or UNIQUE INDEX)")," composed of the ",(0,i.kt)("inlineCode",{parentName:"p"},"NAME")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"PARENT_ID")," columns in the database."),(0,i.kt)("p",null,"This uniqueness constraint can be analogized to file systems. File systems allow directories or files with the same name, but do not allow the same name if the parent directory is specified."),(0,i.kt)("admonition",{type:"info"},(0,i.kt)("p",{parentName:"admonition"},"Through this example, we see:"),(0,i.kt)("ul",{parentName:"admonition"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Key can consist of multiple properties")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Foreign keys can be part of Key")))),(0,i.kt)("p",null,"Let's take another look at another example where the properties that make up Key are all properties based on foreign keys:"),(0,i.kt)(l.Z,{groupId:"language",mdxType:"Tabs"},(0,i.kt)(r.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},"@Entity\npublic interface OrderItem {\n\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)  \n    long id();\n\n    // highlight-next-line\n    @Key   \n    @ManyToOne\n    Order order();\n\n    // highlight-next-line\n    @Key\n    @ManyToOne\n    Product product();\n\n    int quantity();\n\n    // Snapshot of `product.price`\n    BigDecimal unitPrice(); \n}\n"))),(0,i.kt)(r.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-kotlin"},"@Entity\ninterface OrderItem {\n\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    val id: Long\n\n    // highlight-next-line\n    @Key\n    @ManyToOne\n    val order: Order\n\n    // highlight-next-line\n    @Key \n    @ManyToOne\n    val product: Product\n\n    val quantity: Int\n\n    // Snapshot of `product.price`\n    val unitPrice: BigDecimal\n}\n")))))}s.isMDXComponent=!0},91102:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>p,contentTitle:()=>s,default:()=>c,frontMatter:()=>o,metadata:()=>d,toc:()=>m});var a=n(83117),i=(n(67294),n(3905)),l=n(65488),r=n(85162);n(51873),n(39511);const o={sidebar_position:3,title:"Save Mode of Aggregate-Root"},s=void 0,d={unversionedId:"mutation/save-command/save-mode",id:"mutation/save-command/save-mode",title:"Save Mode of Aggregate-Root",description:"Save Modes",source:"@site/docs/mutation/save-command/save-mode.mdx",sourceDirName:"mutation/save-command",slug:"/mutation/save-command/save-mode",permalink:"/jimmer-doc/docs/mutation/save-command/save-mode",draft:!1,editUrl:"https://github.com/babyfish-ct/jimmer-doc/edit/main/docs/mutation/save-command/save-mode.mdx",tags:[],version:"current",lastUpdatedAt:1731974669,formattedLastUpdatedAt:"Nov 19, 2024",sidebarPosition:3,frontMatter:{sidebar_position:3,title:"Save Mode of Aggregate-Root"},sidebar:"tutorialSidebar",previous:{title:"Data Classification",permalink:"/jimmer-doc/docs/mutation/save-command/data-classification"},next:{title:"Save Mode of Associated Objects",permalink:"/jimmer-doc/docs/mutation/save-command/associated-save-mode"}},p={},m=[{value:"Save Modes",id:"save-modes",level:2},{value:"1. INSERT_ONLY",id:"1-insert_only",level:2},{value:"2. UPDATE_ONLY",id:"2-update_only",level:2},{value:"Updating Data by ID",id:"updating-data-by-id",level:3},{value:"Updating Data by Key",id:"updating-data-by-key",level:3},{value:"3. UPSERT",id:"3-upsert",level:2},{value:"Determining Data Existence by Id",id:"determining-data-existence-by-id",level:3},{value:"Determining Data Existence by Key",id:"determining-data-existence-by-key",level:3},{value:"Improved Key-based Determination",id:"improved-key-based-determination",level:3},{value:"4. INSERT_IF_ABSENT",id:"4-insert_if_absent",level:2},{value:"Check Data Existence by Id",id:"check-data-existence-by-id",level:3},{value:"Check Data Existence by Key",id:"check-data-existence-by-key",level:3},{value:"5. NON_IDEMPOTENT_UPSERT",id:"5-non_idempotent_upsert",level:2},{value:"Various Save Methods",id:"various-save-methods",level:2},{value:"Batch Saving Objects of Different Formats",id:"batch-saving-objects-of-different-formats",level:2}],u={toc:m};function c(e){let{components:t,...n}=e;return(0,i.kt)("wrapper",(0,a.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h2",{id:"save-modes"},"Save Modes"),(0,i.kt)("p",null,"The save command supports 5 save modes that control how the aggregate root itself is saved:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"UPSERT: This is the default mode. It first queries to check if the aggregate root object being saved exists:"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"If it doesn't exist: Executes an INSERT statement")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"If it exists: Executes an UPDATE statement")))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"INSERT_ONLY: Unconditionally executes an INSERT statement")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"INSERT_IF_ABSENT: "),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"If the data already exists, ignores the operation")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Otherwise, inserts the data")))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"UPDATE_ONLY: Unconditionally executes an UPDATE statement")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"NON_IDEMPOTENT_UPSERT: "),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"If the object's @Id property or @Key properties are specified, performs behavior equivalent to UPSERT")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Otherwise, performs an INSERT operation"))),(0,i.kt)("admonition",{parentName:"li",type:"note"},(0,i.kt)("p",{parentName:"admonition"},"This behavior is equivalent to JPA's ",(0,i.kt)("inlineCode",{parentName:"p"},"merge")," or Hibernate's ",(0,i.kt)("inlineCode",{parentName:"p"},"saveOrUpdate"),", but it is not recommended in Jimmer.")))),(0,i.kt)("admonition",{type:"caution"},(0,i.kt)("p",{parentName:"admonition"},"Save modes only affect the aggregate root object, not other associated objects."),(0,i.kt)("p",{parentName:"admonition"},"For associated objects, please refer to ",(0,i.kt)("a",{parentName:"p",href:"./associated-save-mode"},"Associated Object Save Mode"),".")),(0,i.kt)("h2",{id:"1-insert_only"},"1. INSERT_ONLY"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"INSERT_ONLY")," means unconditionally inserting data"),(0,i.kt)(l.Z,{groupId:"language",mdxType:"Tabs"},(0,i.kt)(r.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},'List<Book> books = Arrays.asList(\n    Immutables.createBook(draft -> {\n        draft.setName("SQL in Action");\n        draft.setEdition(3);\n        draft.setPrice(new BigDecimal("49.9"));\n        draft.setStoreId(2L);\n    }),\n    Immutables.createBook(draft -> {\n        draft.setName("LINQ in Action");\n        draft.setEdition(2);\n        draft.setPrice(new BigDecimal("39.9"));\n        draft.setStoreId(2L);\n    })\n);\n\nList<Long> allocatedIds = sqlClient    \n    .saveEntities(\n        books, \n        // highlight-next-line\n        SaveMode.INSERT_ONLY\n    )\n    .getItems()\n    .stream()\n    .map(item -> item.getModifiedEntity().id())\n    .collect(Collectors.toList());\n\nSystem.out.println("Allocated ids: " + allocatedIds);\n'))),(0,i.kt)(r.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-kotlin"},'val books = listOf(\n    Book {\n        name = "SQL in Action"\n        edition = 3\n        price = BigDecimal("49.9")\n        storeId = 2L\n    },\n    Book {\n        name = "SQL in Action"\n        edition = 2\n        price = BigDecimal("39.9")\n        storeId = 2L\n    }\n)\n\nval allocatedIds = sqlClient\n    .saveEntities(\n        books,\n        // highlight-next-line\n        SaveMode.INSERT_ONLY\n    )\n    .items\n    .map {\n        it.modifiedEntity.id\n    }\n\nprintln("Allocated ids: $allocatedIds")\n')))),(0,i.kt)("p",null,"INSERT_ONLY works very simply - it inserts unconditionally without any checks."),(0,i.kt)("p",null,"The generated batch operation SQL is as follows:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sql"},"insert into BOOK(NAME, EDITION, PRICE, STORE_ID) values(?, ?, ?, ?)\n/* batch-0: SQL in Action, 3, 49.9, 2 */\n/* batch-1: [LINQ in Action, 2, 39.9, 2 */\n")),(0,i.kt)("p",null,"In this example, since the id property's corresponding column uses database auto-numbering, after the batch insertion is complete, the ids allocated by the database for all data will be returned. The print result will be:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"Allocated ids: [100, 101]\n")),(0,i.kt)("h2",{id:"2-update_only"},"2. UPDATE_ONLY"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"UPDATE_ONLY")," means unconditionally updating data, and it has two scenarios:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"For Id-Specified objects, modify data according to id")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"For Key-Specified objects, modify data according to key"))),(0,i.kt)("h3",{id:"updating-data-by-id"},"Updating Data by ID"),(0,i.kt)(l.Z,{groupId:"language",mdxType:"Tabs"},(0,i.kt)(r.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},'List<Book> books = Arrays.asList(\n    Immutables.createBook(draft -> {\n        draft.setId(3L); // Matched\n        draft.setName("SQL in Action");\n        draft.setEdition(3);\n        draft.setPrice(new BigDecimal("49.9"));\n        draft.setStoreId(2L);\n    }),\n    Immutables.createBook(draft -> {\n        draft.setId(100L); // Not matched\n        draft.setName("LINQ in Action");\n        draft.setEdition(2);\n        draft.setPrice(new BigDecimal("39.9"));\n        draft.setStoreId(2L);\n    })\n);\nBatchSaveResult<Book> result = sqlClient\n    .saveEntities(\n        books,\n        // highlight-next-line\n        SaveMode.UPDATE_ONLY\n    );\nSystem.out.println("Affected row count: " + result.getTotalAffectedRowCount());\n'))),(0,i.kt)(r.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-kotlin"},'val books = listOf(\n    Book {\n        id = 3L\n        name = "SQL in Action"\n        edition = 3\n        price = BigDecimal("49.9")\n        storeId = 2L\n    },\n    Book {\n        id = 100L\n        name = "SQL in Action"\n        edition = 2\n        price = BigDecimal("39.9")\n        storeId = 2L\n    }\n)\nval result = sqlClient\n    .saveEntities(\n        books,\n        // highlight-next-line\n        SaveMode.UPDATE_ONLY\n    )\n\nprintln("Affected row count: ${result.totalAffectedRowCount}")\n')))),(0,i.kt)("p",null,"Since the object's id property is specified, the object is updated based on its id. The generated batch operation SQL is as follows:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sql"},"update BOOK\nset\n    NAME = ?,\n    EDITION = ?,\n    PRICE = ?,\n    STORE_ID = ?\nwhere\n    ID = ?\n/* batch-0: [SQL in Action, 3, 49.9, 2, 3] *\n/* batch-1: [LINQ in Action, 2, 39.9, 2, 100] */\n")),(0,i.kt)("p",null,"This batch operation attempts to modify two records. Assuming the database only has one matching record, the print result will be ",(0,i.kt)("inlineCode",{parentName:"p"},"1"),"."),(0,i.kt)("h3",{id:"updating-data-by-key"},"Updating Data by Key"),(0,i.kt)("p",null,"Assume the Book entity is defined as follows:"),(0,i.kt)(l.Z,{groupId:"language",mdxType:"Tabs"},(0,i.kt)(r.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java",metastring:'title="Book.java"',title:'"Book.java"'},"@Entity\npublic interface Book {\n\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    long id();\n\n    // highlight-next-line\n    @Key\n    String name();\n\n    // highlight-next-line\n    @Key\n    int edition();\n\n    ...other properties that are neither id nor key omitted...\n}\n"))),(0,i.kt)(r.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-kotlin",metastring:'title="Book.kt"',title:'"Book.kt"'},"@Entity\npublic interface Book {\n\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    val id: Long\n\n    // highlight-next-line\n    @Key\n    val name: String\n\n    // highlight-next-line\n    @Key\n    val edition: Int\n\n    ...other properties that are neither id nor key omitted...\n}\n")))),(0,i.kt)("p",null,"Here ",(0,i.kt)("inlineCode",{parentName:"p"},"Book.name")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"Book.edition")," are annotated with ",(0,i.kt)("a",{parentName:"p",href:"../../mapping/advanced/key"},"@Key"),"."),(0,i.kt)(l.Z,{groupId:"language",mdxType:"Tabs"},(0,i.kt)(r.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},'List<Book> books = Arrays.asList(\n    Immutables.createBook(draft -> {\n        // Id is not specified\n        draft.setName("Learning GraphQL");\n        draft.setEdition(3);\n        draft.setPrice(new BigDecimal("49.9"));\n        draft.setStoreId(2L);\n    }),\n    Immutables.createBook(draft -> {\n        // Id is not specified\n        draft.setName("LINQ in Action");\n        draft.setEdition(2);\n        draft.setPrice(new BigDecimal("39.9"));\n        draft.setStoreId(2L);\n    })\n);\nBatchSaveResult<Book> result = sqlClient\n    .saveEntities(\n        books,\n        // highlight-next-line\n        SaveMode.UPDATE_ONLY\n    );\nfor (MutationResultItem<Book> item : result.getItems()) {\n    if (ImmutableObjects.isLoaded(item.getModifiedEntity(), BookProps.ID)) {\n        System.out.println("Data is updated, updated id is " + item.getModifiedEntity().id());\n    } else {\n        System.out.println("Data is not updated");\n    }\n}\n'))),(0,i.kt)(r.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-kotlin"},'val books = listOf(\n    Book {\n        // Id is not specified\n        name = "Learning GraphQL"\n        edition = 3\n        price = BigDecimal("49.9")\n        storeId = 2L\n    },\n    Book {\n        // Id is not specified\n        name = "SQL in Action"\n        edition = 2\n        price = BigDecimal("39.9")\n        storeId = 2L\n    }\n)\nval result = sqlClient\n    .saveEntities(\n        books,\n        // highlight-next-line\n        SaveMode.UPDATE_ONLY\n    )\nfor (item in result.item) {\n    if (isLoaded(item.modifiedEntity, Book::id)) {\n        println("Data is updated, updated id is ${item.isModified}")\n    } else {\n        println("Data is not updated")\n    }\n}\n')))),(0,i.kt)("p",null,"Since the object's id property is not specified, the object is updated based on its key. The generated batch operation SQL is as follows:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sql"},"update BOOK\nset\n    PRICE = ?,\n    STORE_ID = ?\nwhere\n    NAME = ?\n    and\n    EDITION = ?\n/* batch-0: [49.9, 2, Learning GraphQL, 3] */\n/* batch-1: [39.9, 2, LINQ in Action, 2] */\n")),(0,i.kt)("p",null,"The print result will be:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"Data is updated, updated id is 3\nData is not updated\n")),(0,i.kt)("h2",{id:"3-upsert"},"3. UPSERT"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"UPSERT")," means first checking if the data exists - if it exists then update it, otherwise insert it"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"For Id-Specified objects, existence is determined by id, then deciding between INSERT or UPDATE")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"For Key-Specified objects, existence is determined by key, then deciding between INSERT or UPDATE"))),(0,i.kt)("h3",{id:"determining-data-existence-by-id"},"Determining Data Existence by Id"),(0,i.kt)(l.Z,{groupId:"language",mdxType:"Tabs"},(0,i.kt)(r.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},'List<Book> books = Arrays.asList(\n    Immutables.createBook(draft -> {\n        draft.setId(3L);\n        draft.setName("Learning GraphQL");\n        draft.setEdition(3);\n        draft.setPrice(new BigDecimal("49.9"));\n        draft.setStoreId(2L);\n    }),\n    Immutables.createBook(draft -> {\n        draft.setId(100L);\n        draft.setName("LINQ in Action");\n        draft.setEdition(2);\n        draft.setPrice(new BigDecimal("39.9"));\n        draft.setStoreId(2L);\n    })\n);\n\nsqlClient\n    .saveEntities(\n        books,\n        // highlight-next-line\n        SaveMode.UPSERT\n    );\n'))),(0,i.kt)(r.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-kotlin"},'val books = listOf(\n    Book {\n        id = 3L\n        name = "Learning GraphQL"\n        edition = 3\n        price = BigDecimal("49.9")\n        storeId = 2L\n    },\n    Book {\n        id = 100L\n        name = "SQL in Action"\n        edition = 2\n        price = BigDecimal("39.9")\n        storeId = 2L\n    }\n)\nsqlClient.save(\n    books,\n    // highlight-next-line\n    SaveMode.UPSERT\n)\n')))),(0,i.kt)("p",null,"Jimmer prioritizes using the database's native UPSERT capabilities, so it generates different SQL for different databases"),(0,i.kt)("table",null,(0,i.kt)("thead",null,(0,i.kt)("tr",null,(0,i.kt)("th",null,"Database"),(0,i.kt)("th",null,"Generated SQL"))),(0,i.kt)("tbody",null,(0,i.kt)("tr",null,(0,i.kt)("td",null,"H2"),(0,i.kt)("td",null,(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sql"},"merge into BOOK(\n    ID, NAME, EDITION, PRICE, STORE_ID\n) key(ID) values(\n    ?, ?, ?, ?, ?\n)\n/* batch-0: [3, Learning GraphQL, 3, 49.9, 2] */\n/* batch-1: [100, LINQ in Action, 2, 39.9, 2] */\n")))),(0,i.kt)("tr",null,(0,i.kt)("td",null,"MySQL"),(0,i.kt)("td",null,(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sql"},"insert into BOOK(\n    ID, NAME, EDITION, PRICE, STORE_ID\n) values(?, ?, ?, ?, ?)\non duplicate key update \n    NAME = values(NAME), \n    EDITION = values(EDITION), \n    PRICE = values(PRICE), \n    STORE_ID = values(STORE_ID)\n/* batch-0: [3, Learning GraphQL, 3, 49.9, 2] */\n/* batch-1: [100, LINQ in Action, 2, 39.9, 2] */\n")))),(0,i.kt)("tr",null,(0,i.kt)("td",null,"Postgres"),(0,i.kt)("td",null,(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sql"},"insert into BOOK(\n    ID, NAME, EDITION, PRICE, STORE_ID\n) values(?, ?, ?, ?, ?)\non conflict(ID) do update set\n    NAME = excluded.NAME, \n    EDITION = excluded.EDITION, \n    PRICE = excluded.PRICE, \n    STORE_ID = excluded.STORE_ID)\n/* batch-0: [3, Learning GraphQL, 3, 49.9, 2] */\n/* batch-1: [100, LINQ in Action, 2, 39.9, 2] */\n")))))),(0,i.kt)("h3",{id:"determining-data-existence-by-key"},"Determining Data Existence by Key"),(0,i.kt)("p",null,"If the object's id is not specified, for example:"),(0,i.kt)(l.Z,{groupId:"language",mdxType:"Tabs"},(0,i.kt)(r.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},'List<Book> books = Arrays.asList(\n    Immutables.createBook(draft -> {\n        draft.setName("Learning GraphQL");\n        draft.setEdition(3);\n        draft.setPrice(new BigDecimal("49.9"));\n        draft.setStoreId(2L);\n    }),\n    Immutables.createBook(draft -> {\n        draft.setName("GraphQL in Action");\n        draft.setEdition(3);\n        draft.setPrice(new BigDecimal("49.9"));\n        draft.setStoreId(2L);\n    }),\n    Immutables.createBook(draft -> {\n        draft.setName("LINQ in Action");\n        draft.setEdition(2);\n        draft.setPrice(new BigDecimal("39.9"));\n        draft.setStoreId(2L);\n    }),\n    Immutables.createBook(draft -> {\n        draft.setName("Kotlin in Action");\n        draft.setEdition(2);\n        draft.setPrice(new BigDecimal("39.9"));\n        draft.setStoreId(2L);\n    })\n);\nList<Long> ids = sqlClient\n    .saveEntities(\n        books,\n        // highlight-next-line\n        SaveMode.UPSERT\n    )\n    .getItems()\n    .stream().map(it -> it.getModifiedEntity().id())\n    .collect(Collectors.toList());\nSystem.out.println(ids);\n'))),(0,i.kt)(r.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-kotlin"},'val books = listOf(\n    Book {\n        name = "Learning GraphQL"\n        edition = 3\n        price = BigDecimal("49.9")\n        storeId = 2L\n    },\n    Book {\n        name = "GraphQL in Action"\n        edition = 3\n        price = BigDecimal("49.9")\n        storeId = 2L\n    },\n    Book {\n        name = "SQL in Action"\n        edition = 2\n        price = BigDecimal("39.9")\n        storeId = 2L\n    },\n    Book {\n        name = "Kotlin in Action"\n        edition = 2\n        price = BigDecimal("39.9")\n        storeId = 2L\n    }\n)\nval ids = sqlClient.save(\n    books,\n    // highlight-next-line\n    SaveMode.UPSERT\n).items.map{ it.id }\nprintln(ids)\n')))),(0,i.kt)("p",null,"By default, Jimmer tries to use the database's native UPSERT capabilities whenever possible."),(0,i.kt)("p",null,"However, in this case, it cannot achieve this ",(0,i.kt)("em",{parentName:"p"},"(we'll discuss how to solve this issue shortly)"),"."),(0,i.kt)("p",null,"In this situation, Jimmer will first execute a query, then based on the query results, determine which data should be INSERTed and which should be UPDATEd. This results in three SQL statements:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"Query, with reason provided"),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-sql"},"/* highlight-next-line */\nPurpose: COMMAND(KEY_UNIQUE_CONSTRAINT_REQUIRED)\nSQL: select\n    tb_1_.ID,\n    tb_1_.NAME,\n    tb_1_.EDITION\nfrom BOOK tb_1_\nwhere\n    (tb_1_.NAME, tb_1_.EDITION) in (\n        (? /* Learning GraphQL */, ? /* 3 */), \n        (? /* GraphQL in Action */, ? /* 3 */), \n        (? /* LINQ in Action */, ? /* 2 */), \n        (? /* Kotlin in Action */, ? /* 2 */)\n    )\n")),(0,i.kt)("admonition",{parentName:"li",type:"info"},(0,i.kt)("p",{parentName:"admonition"},"Jimmer prints ",(0,i.kt)("inlineCode",{parentName:"p"},"KEY_UNIQUE_CONSTRAINT_REQUIRED")," in the logs, which is called QueryReason."),(0,i.kt)("p",{parentName:"admonition"},"Jimmer prioritizes using the database's native UPSERT capabilities, and if it cannot do so resulting in a query, it provides the QueryReason to help users investigate and find solutions."))),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"INSERT operation for non-existing data"),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-sql"},"insert into BOOK(\n    NAME, EDITION, PRICE, STORE_ID\n) values(\n    ?, ?, ?, ?\n)\n/* batch-0: [LINQ in Action, 2, 39.9, 2] */\n/* batch-1: [Kotlin in Action, 2, 39.9, 2] */\n"))),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"UPDATE operation for existing data"),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-sql"},"update BOOK\nset\n    PRICE = ?,\n    STORE_ID = ?\nwhere\n    ID = ?\n/* batch-0: [49.9, 2, 3] */\n/* batch-1: [49.9, 2, 12] */\n")))),(0,i.kt)("p",null,"The printed result is:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"[3, 12, 100, 101]\n")),(0,i.kt)("p",null,"Where:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"3 and 12 represent the ids of updated data"),(0,i.kt)("li",{parentName:"ul"},"100 and 101 represent new ids assigned by the database for inserted data")),(0,i.kt)("h3",{id:"improved-key-based-determination"},"Improved Key-based Determination"),(0,i.kt)("p",null,"In the previous example, Jimmer executed a query and provided the QueryReason ",(0,i.kt)("inlineCode",{parentName:"p"},"KEY_UNIQUE_CONSTRAINT_REQUIRED"),"."),(0,i.kt)("p",null,"Jimmer provides detailed documentation comments for all QueryReasons, see ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/babyfish-ct/jimmer/blob/main/project/jimmer-sql/src/main/java/org/babyfish/jimmer/sql/ast/mutation/QueryReason.java"},"QueryReason")," for details."),(0,i.kt)("p",null,"For ",(0,i.kt)("inlineCode",{parentName:"p"},"KEY_UNIQUE_CONSTRAINT_REQUIRED")," specifically, it indicates the need for:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"Creating a unique constraint for ",(0,i.kt)("inlineCode",{parentName:"p"},"Book.name")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"Book.edition")," properties:"),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-sql"},"alter table book\n    add constraint uq_book__name_edition\n        /* highlight-next-line */\n        unique(name, edition);\n")),(0,i.kt)("p",{parentName:"li"},"This is because the database's UPSERT functionality depends on unique constraints ",(0,i.kt)("em",{parentName:"p"},"(or unique indexes)"))),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"Informing Jimmer through the ",(0,i.kt)("inlineCode",{parentName:"p"},"@KeyUniqueConstraint")," annotation that the properties modified by ",(0,i.kt)("inlineCode",{parentName:"p"},"@Key")," have corresponding unique constraints ",(0,i.kt)("em",{parentName:"p"},"(or unique indexes)")," in the database"),(0,i.kt)(l.Z,{groupId:"language",mdxType:"Tabs"},(0,i.kt)(r.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-java",metastring:'title="Book.java"',title:'"Book.java"'},"@Entity\n// highlight-next-line\n@KeyUniqueConstraint\npublic interface Book {\n\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    long id();\n\n    @Key\n    String name();\n\n    @Key\n    int edition();\n\n    ...omitting other properties that are neither id nor key...\n}\n"))),(0,i.kt)(r.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-kotlin",metastring:'title="Book.kt"',title:'"Book.kt"'},"@Entity\n// highlight-next-line\n@KeyUniqueConstraint\npublic interface Book {\n\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    val id: Long\n\n    @Key\n    val name: String\n\n    @Key\n    val edition: Int\n\n    ...omitting other properties that are neither id nor key...\n}\n")))),(0,i.kt)("admonition",{parentName:"li",type:"caution"},(0,i.kt)("p",{parentName:"admonition"},"For MySQL, you need:"),(0,i.kt)("pre",{parentName:"admonition"},(0,i.kt)("code",{parentName:"pre",className:"language-java"},"@KeyUniqueConstraint(noMoreUniqueConstraints = true)\n"))))),(0,i.kt)("p",null,"Once these two improvements are made, when running the previous example again, Jimmer will no longer execute a select statement but instead directly utilize the database's native UPSERT capabilities"),(0,i.kt)("table",null,(0,i.kt)("thead",null,(0,i.kt)("tr",null,(0,i.kt)("th",null,"Database"),(0,i.kt)("th",null,"Generated SQL"))),(0,i.kt)("tbody",null,(0,i.kt)("tr",null,(0,i.kt)("td",null,"H2"),(0,i.kt)("td",null,(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sql"},"merge into BOOK(\n    NAME, EDITION, PRICE, STORE_ID\n) key(\n    /* highlight-next-line */\n    NAME, EDITION\n) values(\n    ?, ?, ?, ?\n)\n/* batch-0: [Learning GraphQL, 3, 49.9, 2] */\n/* batch-1: [GraphQL in Action, 3, 49.9, 2] */\n/* batch-2: [LINQ in Action, 2, 39.9, 2] */\n/* batch-3: [Kotlin in Action, 2, 39.9, 2] */\n")))),(0,i.kt)("tr",null,(0,i.kt)("td",null,"MySQL"),(0,i.kt)("td",null,(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sql"},"insert into BOOK(\n    NAME, EDITION, PRICE, STORE_ID\n) values(?, ?, ?, ?)\non duplicate key update \n    /* fake update to return all ids */ ID = last_insert_id(ID), \n    NAME = values(NAME), \n    EDITION = values(EDITION), \n    PRICE = values(PRICE), \n    STORE_ID = values(STORE_ID)\n/* batch-0: [Learning GraphQL, 3, 49.9, 2] */\n/* batch-1: [GraphQL in Action, 3, 49.9, 2] */\n/* batch-2: [LINQ in Action, 2, 39.9, 2] */\n/* batch-3: [Kotlin in Action, 2, 39.9, 2] */\n")))),(0,i.kt)("tr",null,(0,i.kt)("td",null,"Postgres"),(0,i.kt)("td",null,(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sql"},"insert into BOOK(\n    NAME, EDITION, PRICE, STORE_ID\n) values(?, ?, ?, ?, ?)\non conflict(\n    /* highlight-next-line */\n    NAME, EDITION\n) do update set\n    NAME = excluded.NAME, \n    EDITION = excluded.EDITION, \n    PRICE = excluded.PRICE, \n    STORE_ID = excluded.STORE_ID\nreturning ID\n/* batch-0: [Learning GraphQL, 3, 49.9, 2] */\n/* batch-1: [GraphQL in Action, 3, 49.9, 2] */\n/* batch-2: [LINQ in Action, 2, 39.9, 2] */\n/* batch-3: [Kotlin in Action, 2, 39.9, 2] */\n")))))),(0,i.kt)("admonition",{type:"info"},(0,i.kt)("p",{parentName:"admonition"},"If you are using MySQL, there are two points to note:"),(0,i.kt)("ul",{parentName:"admonition"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Unlike Postgres which can explicitly specify columns used for determining data existence through ",(0,i.kt)("inlineCode",{parentName:"p"},"on conflict(NAME, EDITION)"),",\nMySQL is special in that its ",(0,i.kt)("inlineCode",{parentName:"p"},"on duplicate key")," cannot explicitly specify which columns are used for determining data existence."),(0,i.kt)("p",{parentName:"li"},"Therefore, when an ",(0,i.kt)("inlineCode",{parentName:"p"},"insert ... on duplicate key")," statement doesn't insert the id field, MySQL will determine data existence based on all fields participating in unique constraints, even if these fields belong to multiple different unique constraints."),(0,i.kt)("p",{parentName:"li"},"Thus, you must add an additional parameter ",(0,i.kt)("inlineCode",{parentName:"p"},"noMoreUniqueConstraints")," to the annotation, like:"),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-java"},"@KeyUniqueConstraint(noMoreUniqueConstraints = true)\n")),(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"noMoreUniqueConstraints = true")," tells Jimmer that the table corresponding to the entity has only one unique constraint ",(0,i.kt)("em",{parentName:"p"},"(or unique index)"),".\nUsers need to be responsible for their commitment.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"The SQL generated for MySQL includes:"),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-sql"},"/* fake update to return all ids */ ID = last_insert_id(ID)\n")),(0,i.kt)("p",{parentName:"li"},"This is a relatively tricky technique. If the data is updated, it returns the existing id of the updated data; otherwise, it returns the id assigned by the database for automatically inserted data.")))),(0,i.kt)("p",null,"Apart from utilizing the database's native UPSERT capabilities, the functionality is exactly the same as the previous example, and the printed result will not change at all, as shown below:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"[3, 12, 100, 101]\n")),(0,i.kt)("p",null,"Where:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"3 and 12 represent the ids of updated data"),(0,i.kt)("li",{parentName:"ul"},"100 and 101 represent new ids assigned by the database for inserted data")),(0,i.kt)("h2",{id:"4-insert_if_absent"},"4. INSERT_IF_ABSENT"),(0,i.kt)("p",null,"Check if data exists in the database based on id or key. If it doesn't exist, insert it; otherwise, ignore the operation."),(0,i.kt)("h3",{id:"check-data-existence-by-id"},"Check Data Existence by Id"),(0,i.kt)(l.Z,{groupId:"language",mdxType:"Tabs"},(0,i.kt)(r.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},'List<Book> books = Arrays.asList(\n    Immutables.createBook(draft -> {\n        draft.setId(3L); // Matched\n        draft.setName("SQL in Action");\n        draft.setEdition(3);\n        draft.setPrice(new BigDecimal("49.9"));\n        draft.setStoreId(2L);\n    }),\n    Immutables.createBook(draft -> {\n        draft.setId(100L); // Not matched\n        draft.setName("LINQ in Action");\n        draft.setEdition(2);\n        draft.setPrice(new BigDecimal("39.9"));\n        draft.setStoreId(2L);\n    })\n);\nBatchSaveResult<Book> result = sqlClient\n    .saveEntities(\n        books,\n        // highlight-next-line\n        SaveMode.INSERT_IF_ABSENT\n    );\nSystem.out.println("Affected row count: " + result.getTotalAffectedRowCount());\n'))),(0,i.kt)(r.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-kotlin"},'val books = listOf(\n    Book {\n        id = 3L // Matched\n        name = "SQL in Action"\n        edition = 3\n        price = BigDecimal("49.9")\n        storeId = 2L\n    },\n    Book {\n        id = 100L // Not matched\n        name = "SQL in Action"\n        edition = 2\n        price = BigDecimal("39.9")\n        storeId = 2L\n    }\n)\nval result = sqlClient\n    .saveEntities(\n        books,\n        // highlight-next-line\n        SaveMode.INSERT_IF_ABSENT\n    )\nprintln("Affected row count: ${result.totalAffectedRowCount}")\n')))),(0,i.kt)("p",null,"Jimmer will prioritize using the database's native capabilities for ",(0,i.kt)("inlineCode",{parentName:"p"},"INSERT_IF_ABSENT")," operations, generating different SQL for different databases:"),(0,i.kt)("table",null,(0,i.kt)("thead",null,(0,i.kt)("tr",null,(0,i.kt)("th",null,"Database"),(0,i.kt)("th",null,"Generated SQL"))),(0,i.kt)("tbody",null,(0,i.kt)("tr",null,(0,i.kt)("td",null,"H2"),(0,i.kt)("td",null,(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sql"},"merge into BOOK tb_1_ \nusing(values(?, ?, ?, ?, ?)) tb_2_(\n    ID, NAME, EDITION, PRICE, STORE_ID\n) on tb_1_.ID = tb_2_.ID \n// highlight-next-line\nwhen not matched then \n    insert(ID, NAME, EDITION, PRICE, STORE_ID)\nvalues\n    (tb_2_.ID, tb_2_.NAME, tb_2_.EDITION, tb_2_.PRICE, tb_2_.STORE_ID)\n/* batch-0: [3, SQL in Action, 3, 49.9, 2] */\n/* batch-1: [100, LINQ in Action, 2, 39.9, 2] */\n")))),(0,i.kt)("tr",null,(0,i.kt)("td",null,"MySQL"),(0,i.kt)("td",null,(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sql"},"insert \n// highlight-next-line\nignore \ninto BOOK(ID, NAME, EDITION, PRICE, STORE_ID)\nvalues(?, ?, ?, ?, ?)\n/* batch-0: [3, Learning GraphQL, 3, 49.9, 2] */\n/* batch-1: [100, LINQ in Action, 2, 39.9, 2] */\n")))),(0,i.kt)("tr",null,(0,i.kt)("td",null,"Postgres"),(0,i.kt)("td",null,(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sql"},"insert into BOOK(ID, NAME, EDITION, PRICE, STORE_ID)\nvalues(?, ?, ?, ?, ?)\non conflict(ID) \n// highlight-next-line\ndo nothing\n/* batch-0: [3, Learning GraphQL, 3, 49.9, 2] */\n/* batch-1: [100, LINQ in Action, 2, 39.9, 2] */\n")))))),(0,i.kt)("p",null,"Assuming one record is inserted and one is ignored, the output will be:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"1\n")),(0,i.kt)("h3",{id:"check-data-existence-by-key"},"Check Data Existence by Key"),(0,i.kt)(l.Z,{groupId:"language",mdxType:"Tabs"},(0,i.kt)(r.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},'List<Book> books = Arrays.asList(\n    Immutables.createBook(draft -> {\n        draft.setName("SQL in Action");\n        draft.setEdition(3);\n        draft.setPrice(new BigDecimal("49.9"));\n        draft.setStoreId(2L);\n    }),\n    Immutables.createBook(draft -> {\n        draft.setName("LINQ in Action");\n        draft.setEdition(2);\n        draft.setPrice(new BigDecimal("39.9"));\n        draft.setStoreId(2L);\n    })\n);\nList<Long> ids = sqlClient\n    .saveEntities(\n        books,\n        SaveMode.INSERT_IF_ABSENT\n    )\n    .getItems()\n    .stream()\n    .map(it -> it.getModifiedEntity().id())\n    .collect(Collectors.toList());\nSystem.out.println(ids);\n'))),(0,i.kt)(r.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-kotlin"},'val books = listOf(\n    Book {\n        name = "SQL in Action"\n        edition = 3\n        price = BigDecimal("49.9")\n        storeId = 2L\n    },\n    Book {\n        name = "SQL in Action"\n        edition = 2\n        price = BigDecimal("39.9")\n        storeId = 2L\n    }\n)\nval ids = sqlClient\n    .saveEntities(\n        books,\n        // highlight-next-line\n        SaveMode.INSERT_IF_ABSENT\n    )\n    .items\n    .map { it.originalEntity.id }\nprintln(ids)\n')))),(0,i.kt)("admonition",{type:"info"},(0,i.kt)("p",{parentName:"admonition"},"In this case, Jimmer will try to utilize the database's native capabilities for ",(0,i.kt)("inlineCode",{parentName:"p"},"INSERT_IF_ABSENT")," operations whenever possible.\nIf this isn't possible, Jimmer will perform a query to determine whether to proceed with insertion or ignore the operation, and will inform developers of the query reason."),(0,i.kt)("p",{parentName:"admonition"},"However, the scenario where a query is needed for determination has already been discussed in the previous ",(0,i.kt)("inlineCode",{parentName:"p"},"UPSERT")," section.\nTo simplify this article, let's assume no query is needed and we can directly use the database's native ",(0,i.kt)("inlineCode",{parentName:"p"},"INSERT_IF_ABSENT")," capability.")),(0,i.kt)("p",null,"Jimmer generates different SQL for different databases:"),(0,i.kt)("table",null,(0,i.kt)("thead",null,(0,i.kt)("tr",null,(0,i.kt)("th",null,"Database"),(0,i.kt)("th",null,"Generated SQL"))),(0,i.kt)("tbody",null,(0,i.kt)("tr",null,(0,i.kt)("td",null,"H2"),(0,i.kt)("td",null,(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sql"},"merge into BOOK tb_1_ \nusing(values(?, ?, ?, ?, ?)) tb_2_(\n    ID, NAME, EDITION, PRICE, STORE_ID\n) on \n    // highlight-next-line\n    tb_1_.NAME = tb_2_.NAME \nand \n    // highlight-next-line\n    tb_1_.EDITION = tb_2_.EDITION \nwhen\n    // highlight-next-line\n    not matched then \n    insert(ID, NAME, EDITION, PRICE, STORE_ID)\nvalues\n    (tb_2_.ID, tb_2_.NAME, tb_2_.EDITION, tb_2_.PRICE, tb_2_.STORE_ID)\n/* batch-0: [3, SQL in Action, 3, 49.9, 2] */\n/* batch-1: [100, LINQ in Action, 2, 39.9, 2] */\n")))),(0,i.kt)("tr",null,(0,i.kt)("td",null,"MySQL"),(0,i.kt)("td",null,(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sql"},"insert \n// highlight-next-line\nignore \ninto BOOK(ID, NAME, EDITION, PRICE, STORE_ID)\nvalues(?, ?, ?, ?, ?)\n/* batch-0: [3, Learning GraphQL, 3, 49.9, 2] */\n/* batch-1: [100, LINQ in Action, 2, 39.9, 2] */\n")))),(0,i.kt)("tr",null,(0,i.kt)("td",null,"Postgres"),(0,i.kt)("td",null,(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sql"},"insert into BOOK(ID, NAME, EDITION, PRICE, STORE_ID)\nvalues(?, ?, ?, ?, ?)\non conflict(\n    // highlight-next-line\n    NAME, EDITION\n)\n// highlight-next-line\ndo nothing\nreturning ID\n/* batch-0: [3, Learning GraphQL, 3, 49.9, 2] */\n/* batch-1: [100, LINQ in Action, 2, 39.9, 2] */\n")))))),(0,i.kt)("p",null,"The output will be:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"[3, 100]\n")),(0,i.kt)("p",null,"Where:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"The first record already exists, so the insert operation is ignored, and the existing ID is 3"),(0,i.kt)("li",{parentName:"ul"},"The second record doesn't exist, so insertion is performed with a new auto-generated ID of 100")),(0,i.kt)("h2",{id:"5-non_idempotent_upsert"},"5. NON_IDEMPOTENT_UPSERT"),(0,i.kt)("p",null,"We've already demonstrated four modes: ",(0,i.kt)("inlineCode",{parentName:"p"},"INSERT_ONLY"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"UPDATE_ONLY"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"UPSERT"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},"INSERT_IF_ABSENT"),".\nIn the previous examples, the saved objects were either Id-specified or Key-specified objects."),(0,i.kt)("p",null,"Now, let's discuss saving Wild objects, which have neither id nor key."),(0,i.kt)(l.Z,{groupId:"language",mdxType:"Tabs"},(0,i.kt)(r.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},'List<Book> books = Arrays.asList(\n    Immutables.createBook(draft -> {\n        draft.setPrice(new BigDecimal("49.9"));\n        draft.setStoreId(2L);\n    }),\n    Immutables.createBook(draft -> {\n        draft.setPrice(new BigDecimal("39.9"));\n        draft.setStoreId(2L);\n    })\n);\nList<Long> ids = sqlClient\n    .saveEntities(\n        books,\n        // Default SaveMode.UPSERT\n    )\n    .getItems()\n    .stream()\n    .map(it -> it.getModifiedEntity().id())\n    .collect(Collectors.toList());\nSystem.out.println(ids);\n'))),(0,i.kt)(r.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-kotlin"},'val books = listOf(\n    Book {\n        price = BigDecimal("49.9")\n        storeId = 2L\n    },\n    Book {\n        price = BigDecimal("39.9")\n        storeId = 2L\n    }\n)\nval ids = sqlClient\n    .saveEntities(\n        books,\n        // Default SaveMode.UPSERT\n    )\n    .items\n    .map { it.originalEntity.id }\nprintln(ids)\n')))),(0,i.kt)("p",null,"This code will result in the following exception ",(0,i.kt)("em",{parentName:"p"},"(formatted for readability)"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sh"},'Save error caused by the path: "<root>": \n    Cannot save illegal entity object whose type is \n    "com.yourproject.model.Book", entity with \n    // highlight-next-line\n    neither id nor key \n    cannot be accepted. \n    There are 3 ways to fix this problem: \n    1. Specify the id property "id" for save objects; \n    2. Use the annotation "org.babyfish.jimmer.sql.Key" \n        to decorate some scalar or foreign key properties in entity type, \n        or call "setKeyProps" of the save command, to specify the key \n        properties of "com.yourproject.model.Book", \n        and finally specified the values of key properties of saved objects; \n    3. Specify the aggregate-root save mode of the save command to \n        "INSERT_ONLY"(function changed)", \n        or \n        // highlight-next-line\n        "NON_IDEMPOTENT_UPSERT"\n')),(0,i.kt)("p",null,"To save wild objects, you can use ",(0,i.kt)("inlineCode",{parentName:"p"},"NON_IDEMPOTENT_UPSERT"),", which provides the following functionality:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"If the saved object is a wild object, it's equivalent to ",(0,i.kt)("inlineCode",{parentName:"li"},"INSERT_ONLY")," mode, which is a non-idempotent operation"),(0,i.kt)("li",{parentName:"ul"},"Otherwise, it's equivalent to ",(0,i.kt)("inlineCode",{parentName:"li"},"UPSERT")," mode, which is an idempotent operation")),(0,i.kt)("admonition",{type:"caution"},(0,i.kt)("p",{parentName:"admonition"},"This behavior is equivalent to JPA's ",(0,i.kt)("inlineCode",{parentName:"p"},"merge")," or Hibernate's ",(0,i.kt)("inlineCode",{parentName:"p"},"saveOrUpdate"),"."),(0,i.kt)("p",{parentName:"admonition"},"However, this mode may mix idempotent and non-idempotent operations, so it's not recommended.")),(0,i.kt)("h2",{id:"various-save-methods"},"Various Save Methods"),(0,i.kt)("p",null,"Jimmer provides various save methods, many of which are equivalent:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Save a single entity object"),(0,i.kt)("table",{parentName:"li"},(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"Original Method"),(0,i.kt)("th",{parentName:"tr",align:null},"Equivalent Shortcut Method"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"save(entity, SaveMode.UPSERT)"),(0,i.kt)("td",{parentName:"tr",align:null},"save(entity)")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"save(entity, SaveMode.INSERT_ONLY)"),(0,i.kt)("td",{parentName:"tr",align:null},"insert(entity)")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"save(entity, SaveMode.UPDATE_ONLY)"),(0,i.kt)("td",{parentName:"tr",align:null},"update(entity)")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"save(entity, SaveMode.INSERT_IF_ABSENT)"),(0,i.kt)("td",{parentName:"tr",align:null},"insertIfAbsent(entity)"))))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Save a single InputDTO object"),(0,i.kt)("table",{parentName:"li"},(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"Original Method"),(0,i.kt)("th",{parentName:"tr",align:null},"Equivalent Shortcut Method"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"save(inputDTO, SaveMode.UPSERT)"),(0,i.kt)("td",{parentName:"tr",align:null},"save(inputDTO)")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"save(inputDTO, SaveMode.INSERT_ONLY)"),(0,i.kt)("td",{parentName:"tr",align:null},"insert(inputDTO)")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"save(inputDTO, SaveMode.UPDATE_ONLY)"),(0,i.kt)("td",{parentName:"tr",align:null},"update(inputDTO)")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"save(inputDTO, SaveMode.INSERT_IF_ABSENT)"),(0,i.kt)("td",{parentName:"tr",align:null},"insertIfAbsent(inputDTO)"))))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Batch save multiple entity objects"),(0,i.kt)("table",{parentName:"li"},(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"Original Method"),(0,i.kt)("th",{parentName:"tr",align:null},"Equivalent Shortcut Method"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"saveEntities(entities, SaveMode.UPSERT)"),(0,i.kt)("td",{parentName:"tr",align:null},"saveEntities(entities)")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"saveEntities(entities, SaveMode.INSERT_ONLY)"),(0,i.kt)("td",{parentName:"tr",align:null},"insertEntities(entities)")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"saveEntities(entities, SaveMode.UPDATE_ONLY)"),(0,i.kt)("td",{parentName:"tr",align:null},"updateEntities(entities)")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"saveEntities(entities, SaveMode.INSERT_IF_ABSENT)"),(0,i.kt)("td",{parentName:"tr",align:null},"insertEntitiesIfAbsent(entities)"))))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Batch save multiple InputDTO objects"),(0,i.kt)("table",{parentName:"li"},(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"Original Method"),(0,i.kt)("th",{parentName:"tr",align:null},"Equivalent Shortcut Method"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"saveInputs(inputDTOs, SaveMode.UPSERT)"),(0,i.kt)("td",{parentName:"tr",align:null},"saveInputs(inputDTOs)")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"saveInputs(inputDTOs, SaveMode.INSERT_ONLY)"),(0,i.kt)("td",{parentName:"tr",align:null},"insertInputs(inputDTOs)")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"saveInputs(inputDTOs, SaveMode.UPDATE_ONLY)"),(0,i.kt)("td",{parentName:"tr",align:null},"updateInputs(inputDTOs)")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"saveInputs(inputDTOs, SaveMode.INSERT_IF_ABSENT)"),(0,i.kt)("td",{parentName:"tr",align:null},"insertInputsIfAbsent(inputDTOs)")))))),(0,i.kt)("h2",{id:"batch-saving-objects-of-different-formats"},"Batch Saving Objects of Different Formats"),(0,i.kt)("p",null,"To better demonstrate Jimmer's batch modification features, all examples in this article use the ",(0,i.kt)("inlineCode",{parentName:"p"},"saveEntities")," method to save multiple objects, rather than using the ",(0,i.kt)("inlineCode",{parentName:"p"},"save")," method to save a single object."),(0,i.kt)("p",null,"These examples flexibly adjust the format of the objects being saved to demonstrate different functionalities. However, for each specific example, all objects saved by the ",(0,i.kt)("inlineCode",{parentName:"p"},"saveEntities")," method have the same format."),(0,i.kt)("p",null,"What happens if you try to use the ",(0,i.kt)("inlineCode",{parentName:"p"},"saveEntities")," method to save multiple objects with different formats?"),(0,i.kt)("p",null,"Jimmer will first group these objects by format, then apply all the above functionalities to each group."))}c.isMDXComponent=!0}}]);